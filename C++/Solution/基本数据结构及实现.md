#### 链表类问题总结

特点：每个节点有一个值，和一个指向下一个节点的指针

特点决定了 <u>很多链表类问题用**递归**来解决</u>

不能直接获取任意节点值，也不能直接获得总长度



基本表示：

```c++
struct ListNode {
  int val;
  ListNode* next;
  ListNode(int x) : val(x), next(nullptr) {}
}
```



处理链表类问题经常会因为对当前节点进行操作而导致内存或 指针出现问题，解决方法：

- 尽量处理当前节点的下一个节点，而非节点本身
- 建立一个虚拟节点 dummy node，指向当前链表的头节点，即使所有节点都被删除，还保留dummy node，最后返回dummy->next即可



##### 翻转链表

递归法：

```c++

```

非递归法：

```c++

```

##### 翻转部分链表

```c++

```







#### 哈希相关总结

##### 手动实现hashset/hashmap

```c++
class myHashSet {
private:
  vector<list<int>> vec;
public:
  const int staitc base = 769; //质数
  static int hash(int key) {
    return key % base;
  }
  myHashSet() : vec(base);
  
  void add(int key) {
        int hashKey = hash(key);
        for (auto it = vec[hashKey].begin(); it != vec[hashKey].end(); it++) {
            if (*it == key) return;
        }
        vec[hashKey].push_back(key);
    }
    
    void remove(int key) {
        int hashKey = hash(key);
        for (auto it = vec[hashKey].begin(); it != vec[hashKey].end(); it++) {
            if (*it == key) {
                vec[hashKey].erase(it); 
                return;
            }
        }
    }
    
    /** Returns true if this set contains the specified element */
    bool contains(int key) {
        int hashKey = hash(key);
        for (auto it = vec[hashKey].begin(); it != vec[hashKey].end(); it++) {
            if (*it == key) return true;
        }
        return false;
    }
}
```



#### 迭代器实现

【LeetCode 341】 

两种思路：

- 递归：其实也就是dfs的方法，不过迭代器的思想不应该是递归解决；递归也就是在构造函数中就展开，迭代器应该是边访问边进行展开

  - 迭代

    具体思路：

    用栈来解决，首先将这个内嵌列表逆序放入栈内，原因是栈是先进后出，所以需要逆序

    然后在每次调用`hasNext`的时候用栈进行展开

    

