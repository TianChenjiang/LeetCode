字符串的匹配，回文串可以用递归/DP

如果题目已经说有序，那么可以用二分



遇到两个字符串的比较，可以用**HashMap**统计两个字符的频率

字符串并且求极值 -> DP



字符串中两个元素比较重要：字符的索引以及字符的频率；这个看题目而定







### 易错点

- for循环中如果是在开始步骤做操作，那么for循环结束后还需要多加一步，因此最好还是在做完操作再判断

  比如这个把数字分组的操作

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
      vector<int> dummy;
      for (int id : ids) {
          dummy.push_back(id);
          if (dummy.size() == groupSize) {
             res.push_back(dummy);
             dummy.clear();
          }
      }
  }
  ```
如果用下面的做法，是在一开始判断，那么如果最后一个元素做完的话就刚好不能添加到结果，还需要多加一步for循环结束的操作。因此不如上面的做法

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
              vector<int> dummy;
              for (int id : ids) {
                  if (dummy.size() == groupSize) {
                      res.push_back(dummy);
                      dummy.clear();
                  }
                  dummy.push_back(id);
              }
              res.push_back(dummy);
          }
  ```

  检查方法：数组操作用头和尾来进行验证