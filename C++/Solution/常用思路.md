字符串的匹配，回文串可以用递归/DP

如果题目已经说**有序**，那么可以用**二分**



遇到两个字符串的比较，可以用**HashMap**统计两个字符的频率

字符串并且求极值 -> DP



字符串中两个元素比较重要：字符的索引以及字符的频率；这个看题目而定



如果两个字符串做对比，可以用hash存一个，然后边遍历另一个边比较hash



如果数组中，相互之间关系很大，可以用**单调栈**；或者说最后结果要按顺序来排，并需要反复调整达到最优解的，可以用单调栈（Leetcode 316）

[单调栈详解](https://www.cnblogs.com/grandyang/p/8887985.html)

> 线性的时间复杂度是其最大的优势，每个数字只进栈并处理一次，而解决问题的核心就在处理这块，当前数字如果破坏了单调性，就会触发处理栈顶元素的操作，而触发数字有时候是解决问题的一部分，比如在 [Trapping Rain Water](http://www.cnblogs.com/grandyang/p/4402392.html) 中作为右边界。有时候仅仅触发作用，比如在 [Largest Rectangle in Histogram](http://www.cnblogs.com/grandyang/p/4322653.html) 中是为了开始处理栈顶元素，如果仅作为触发，可能还需要在数组末尾增加了一个专门用于触发的数字。另外需要注意的是，虽然是递增或递减栈，但里面实际存的数字并不一定是递增或递减的，因为我们可以存坐标，而这些坐标带入数组中才会得到递增或递减的数。所以对于玩数组的题，如果相互之间关联很大，那么就可以考虑考虑单调栈能否解题。

字符串也能当成单调栈来用



动态规划的注意点：

一定明确好dp数组的含义，非常明确

初始值需要考虑好，并且代入验证



可以用大小为256的数组代替hashmap，来存放ascii码（也就是可以存各种字母）

结果问个数，而不问具体的取值的时候发散思维



删除一个vector中的元素，可能没必要真的删除，只需要一个指针，指向上一个元素即可 [LeetCode 435]



取模运算的分配律：

```c++
(a + b) % p = (a % p + b % p) % p 
(a - b) % p = (a % p - b % p) % p 
(a * b) % p = (a % p * b % p) % p 
(a^b) % p = ((a % p)^b) % p
```



涉及到连通量和连通块的问题，可以用BFS，DFS，并差集来解决



对于Cx2的排列问题，可以用求和公式 N * (N - 1) / 2 来解决



求子区间 - 滑动窗口



如果出现交替变化，比如增减增减这种，可以用两个状态数组来进行记录【LeetCode978, 买股票问题】



在一个数组中[left, right] 范围内，最多由K个不同整数组成子数组的个数为right - left + 1

> 例如 `[2,4,3,5]` 满足条件，满足条件的子数组是 `[2,4,3,5], [4,3,5], [3,5], [5]` 四个子区间。



一个r行，c列的二维数组，总元素有r * c个，第 x 个元素和矩阵的对应关系是` matrix[x / c][x % c] = value`

初始化一次，多次检索，可以做预处理提升效率；比如前缀和

判断一个数是否为2的指数：`if (num & (num-1) == 0)`

涉及到数组中两个元素之间的大小关系 - 单调栈



实现循环数组的方法：

- 如果最多循环两次，那可以直接在数组后面加上一份拷贝
- 取模运算



如果找不到符合题意的那就返回-1，可以先初始化为-1，如果能找到就修改，没找到直接返回



使用第二个栈可以让第一个栈中的元素进行reverse



如果能用递归，思考一下能否用栈来解决



判断左右括号是否匹配：用一个变量cnt，遇到左括号+1，右括号-1，如果最后=0，那么匹配







### 易错点

- 首先对边界元素进行判断，避免后面的过程漏掉这种特殊情况

- for循环中如果是在开始步骤做操作，那么for循环结束后还需要多加一步，因此最好还是在做完操作再判断

  比如这个把数字分组的操作

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
      vector<int> dummy;
      for (int id : ids) {
          dummy.push_back(id);
          if (dummy.size() == groupSize) {
             res.push_back(dummy);
             dummy.clear();
          }
      }
  }
  ```
如果用下面的做法，是在一开始判断，那么如果最后一个元素做完的话就刚好不能添加到结果，还需要多加一步for循环结束的操作。因此不如上面的做法

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
              vector<int> dummy;
              for (int id : ids) {
                  if (dummy.size() == groupSize) {
                      res.push_back(dummy);
                      dummy.clear();
                  }
                  dummy.push_back(id);
              }
              res.push_back(dummy);
          }
  ```

  检查方法：数组操作用头和尾来进行验证

- 注意可能做大数字加法，乘法的操作，要提前取long。比如`(long long)mid * mid <= x`

- 数组里元素之间的相互比较，需要考虑数组的开头和末尾元素，一种方法是在首元素和末尾加上一个值，这样就可以不需要进行额外的判断

- 如果数字可能很大，需要用long long进行存储

- 外部函数如果多次调用，看看能否加引用，不加的话可能会超时。LeetCode 947

- C++的/会自动四舍五入，比如3/5, 结果是0，需要计算double(3)/5,结果才是0.6

- 计算除法的时候，小心除数可能为0

- 如果循环里面有if分支，并且有对最终结果的影响，需要考虑两点：

  - 是否从if和else分支跳出都能更新结果？ LeetCode 674
  - 是否不进入for循环的数据也能返回正确结果？
  
- 注意条件判断的时候，边界条件，比如等于，不能包含在对结果有影响的分支 LeetCode 665

- 如果是普通数组，记得初始化为0 `int counts[26]; memset(counts, 0, sizeof(counts));`

- 如果存储26个字母的map，可以用int数组来存储， 比较省空间

