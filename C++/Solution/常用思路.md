字符串的匹配，回文串可以用递归/DP

如果题目已经说**有序**，那么可以用**二分**



遇到两个字符串的比较，可以用**HashMap**统计两个字符的频率

字符串并且求极值 -> DP



字符串中两个元素比较重要：字符的索引以及字符的频率；这个看题目而定



如果两个字符串做对比，可以用hash存一个，然后边遍历另一个边比较hash



如果数组中，相互之间关系很大，可以用**单调栈**；或者说最后结果要按顺序来排，并需要反复调整达到最优解的，可以用单调栈（Leetcode 316）

[单调栈详解](https://www.cnblogs.com/grandyang/p/8887985.html)

> 线性的时间复杂度是其最大的优势，每个数字只进栈并处理一次，而解决问题的核心就在处理这块，当前数字如果破坏了单调性，就会触发处理栈顶元素的操作，而触发数字有时候是解决问题的一部分，比如在 [Trapping Rain Water](http://www.cnblogs.com/grandyang/p/4402392.html) 中作为右边界。有时候仅仅触发作用，比如在 [Largest Rectangle in Histogram](http://www.cnblogs.com/grandyang/p/4322653.html) 中是为了开始处理栈顶元素，如果仅作为触发，可能还需要在数组末尾增加了一个专门用于触发的数字。另外需要注意的是，虽然是递增或递减栈，但里面实际存的数字并不一定是递增或递减的，因为我们可以存坐标，而这些坐标带入数组中才会得到递增或递减的数。所以对于玩数组的题，如果相互之间关联很大，那么就可以考虑考虑单调栈能否解题。

字符串也能当成单调栈来用





### 易错点

- for循环中如果是在开始步骤做操作，那么for循环结束后还需要多加一步，因此最好还是在做完操作再判断

  比如这个把数字分组的操作

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
      vector<int> dummy;
      for (int id : ids) {
          dummy.push_back(id);
          if (dummy.size() == groupSize) {
             res.push_back(dummy);
             dummy.clear();
          }
      }
  }
  ```
如果用下面的做法，是在一开始判断，那么如果最后一个元素做完的话就刚好不能添加到结果，还需要多加一步for循环结束的操作。因此不如上面的做法

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
              vector<int> dummy;
              for (int id : ids) {
                  if (dummy.size() == groupSize) {
                      res.push_back(dummy);
                      dummy.clear();
                  }
                  dummy.push_back(id);
              }
              res.push_back(dummy);
          }
  ```

  检查方法：数组操作用头和尾来进行验证