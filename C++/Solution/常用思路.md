字符串的匹配，回文串可以用递归/DP

如果题目已经说**有序**，那么可以用**二分**



遇到两个字符串的比较，可以用**HashMap**统计两个字符的频率

字符串并且求极值 -> DP



字符串中两个元素比较重要：字符的索引以及字符的频率；这个看题目而定



如果两个字符串做对比，可以用hash存一个，然后边遍历另一个边比较hash



如果数组中，相互之间关系很大，可以用**单调栈**；或者说最后结果要按顺序来排，并需要反复调整达到最优解的，可以用单调栈（Leetcode 316）

[单调栈详解](https://www.cnblogs.com/grandyang/p/8887985.html)

> 线性的时间复杂度是其最大的优势，每个数字只进栈并处理一次，而解决问题的核心就在处理这块，当前数字如果破坏了单调性，就会触发处理栈顶元素的操作，而触发数字有时候是解决问题的一部分，比如在 [Trapping Rain Water](http://www.cnblogs.com/grandyang/p/4402392.html) 中作为右边界。有时候仅仅触发作用，比如在 [Largest Rectangle in Histogram](http://www.cnblogs.com/grandyang/p/4322653.html) 中是为了开始处理栈顶元素，如果仅作为触发，可能还需要在数组末尾增加了一个专门用于触发的数字。另外需要注意的是，虽然是递增或递减栈，但里面实际存的数字并不一定是递增或递减的，因为我们可以存坐标，而这些坐标带入数组中才会得到递增或递减的数。所以对于玩数组的题，如果相互之间关联很大，那么就可以考虑考虑单调栈能否解题。

字符串也能当成单调栈来用



动态规划的注意点：

一定明确好dp数组的含义，非常明确

初始值需要考虑好，并且代入验证



可以用大小为256的数组代替hashmap，来存放ascii码（也就是可以存各种字母）

结果问个数，而不问具体的取值的时候发散思维



删除一个vector中的元素，可能没必要真的删除，只需要一个指针，指向上一个元素即可 [LeetCode 435]



取模运算的分配律：

```c++
(a + b) % p = (a % p + b % p) % p 
(a - b) % p = (a % p - b % p) % p 
(a * b) % p = (a % p * b % p) % p 
(a^b) % p = ((a % p)^b) % p
```





### 易错点

- 首先对边界元素进行判断，避免后面的过程漏掉这种特殊情况

- for循环中如果是在开始步骤做操作，那么for循环结束后还需要多加一步，因此最好还是在做完操作再判断

  比如这个把数字分组的操作

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
      vector<int> dummy;
      for (int id : ids) {
          dummy.push_back(id);
          if (dummy.size() == groupSize) {
             res.push_back(dummy);
             dummy.clear();
          }
      }
  }
  ```
如果用下面的做法，是在一开始判断，那么如果最后一个元素做完的话就刚好不能添加到结果，还需要多加一步for循环结束的操作。因此不如上面的做法

  ```c++
  for (auto [groupSize, ids] : m) { //[0,6,2,4,3,1] 
              vector<int> dummy;
              for (int id : ids) {
                  if (dummy.size() == groupSize) {
                      res.push_back(dummy);
                      dummy.clear();
                  }
                  dummy.push_back(id);
              }
              res.push_back(dummy);
          }
  ```

  检查方法：数组操作用头和尾来进行验证

- 注意可能做大数字加法，乘法的操作，要提前取long。比如`(long long)mid * mid <= x`

- 数组里元素之间的相互比较，需要考虑数组的开头和末尾元素，一种方法是在首元素和末尾加上一个值，这样就可以不需要进行额外的判断

- 如果数字可能很大，需要用long long进行存储

- 外部函数如果多次调用，看看能否加引用，不加的话可能会超时。LeetCode 947

- C++的/会自动四舍五入，比如3/5, 结果是0，需要计算double(3)/5,结果才是0.6

- 计算除法的时候，小心除数可能为0

- 如果循环里面有if分支，并且有对最终结果的影响，需要考虑两点：

  - 是否从if和else分支跳出都能更新结果？ LeetCode 674
  - 是否不进入for循环的数据也能返回正确结果？