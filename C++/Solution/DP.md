# Dynamic Programming

比较

暴力：枚举所有的结果

贪心：有时候可能“鼠目寸光”，每次只考虑眼前的情况，取得眼前的最优解

DP: 把一个大问题拆成子问题，分别求这几个子问题的解。

​		核心：自带剪枝，尽量缩小解空间



举例：凑钱问题

> 有面值为1元，5元，11元的钞票数张，最少用几张凑出15元？

贪心：11 + 4*1 = 15  不是最优解，因为4元很难凑出

DP:      f(n) = min(f(n-1), f(n-5),  f(n-11)) + 1





#### 判定标准

1. 无后效性：未来与过去无关，给定某一状态，这个状态以后的发展和原来是如何到达这个状态的是没有关系的
2. 最优子结构：子问题的解也是最优的



#### 算法设计

1. 设计状态，表示局面
2. 我从哪里来/我到哪里去    当前状态是从什么状态转移来的/这个状态会转移到什么状态



#### 实现DP的两种方式：按顺序递推/记忆化搜索





[一道最长递增子序列问题](https://blog.csdn.net/wbin233/article/details/77570070)

相关题目 /5.md


每一步都是一个局部最优解，就是每一步都已经能得到和结果要求的一个子步骤