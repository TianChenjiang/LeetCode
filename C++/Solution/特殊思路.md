### 5626. 十-二进制数的最少数目

等价于求字符串中出现的最大的数字（不断组合0/1串，总能组合成功，因此就看最高位是多少，那就至少需要多少个0/1串）

```c++
class Solution {
public:
    int minPartitions(string n) {
        int ret = 0;
        for(char c : n) {
            ret = max(ret, c - '0');
        }
        return ret;
    }
};
```



### 5625 比赛的配对次数

> 给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：
>
> 如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。
> 如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。
> 返回在比赛中进行的配对次数，直到决出获胜队伍为止。

每场比赛淘汰一支队伍，那么最后只剩一支队伍，也就需要n-1场比赛来淘汰



字符串也意味着一系列ascii值的集合



### 448 找到所有数组中消失的数字

这个是对空间复杂度有要求，用到一个特殊技巧：对数组的原地修改

方法的核心在于利用索引作为另一种存储空间，然后修改原来的数字（比如取反或者加n）来表示有这个元素

以[4,1,3,4]为例，遍历数组，让nums[nums[i]-1]取反，因此结果为[-4,1,-3,-4]，所以缺的就是2





#### 异或的妙用

定义：

```c++
x ^ y = (!x and y)  or (x and !y)
```

也就是相同为0，相异为1（位运算来看就是：假如x和y相同，那么x取反，和y做and，结果就是0）

https://mp.weixin.qq.com/s/pDXzZoSByzYKkim71qCsCw

异或的几点性质：

- 相同为0，相异为1
- 任何数与0做异或都为原来数 0 ^ n = n
- 交换性： x ^ y = y ^ x
- 自反性：x^y^y = x 假如a^b=c，那么现在知道a和c，通过c^a可以得到b（因为a^b^a=b)
- $$∀i∈Z，4i \oplus (4i+1) \oplus (4i+2) \oplus (4i+3) = 0$$


##### 经典例题1：

> 给你一个包含有 n - 1 个元素的数组，其中每个数字在 [1, n] 的范围内，且不重复。也就是从 1 到 n 这 n 个数字，有一个数字没有出现在这个数组中。编写一个算法，找到这个丢失的数字。

计算出1～N这n个数字的异或值，然后再把数组中所有的值与刚才结果做异或，结果就是这个missing number

（不过也可以用求和公式直接求1～N的和，然后减去数组和）

（核心在于这样的计算式，那个多余的数字出现了一次，因此最后留下它了）

##### 经典例题2:

> 给你一个包含有 n + 1 个元素的数组，其中每个数字在 [1, n] 的范围内，且 1 到 n 每个数字都会出现。也就是从 1 到 n 这 n 个数字，有一个数字在这个数组中出现了两次。编写一个算法，找到这个多余的数字。

解法基本相同，首先计算出从 **1** 到 **n** 这 n 个数字的异或值，然后，再将数组中的所有元素依次和这个值做异或，最终得到的结果，就是这个多余的数字

（核心在于这样的计算式，那个多余的数字出现了三次，因此最后留下它了）

结论：

一个数字和自己做偶数次异或运算，结果为 0；一个数字和自己做奇数次异或运算，结果为 1。



##### 交换数字

```c++
x ^= y;
y ^= x;
x ^= y;
```

第二条语句：

<img src="../../../../学习/笔记合集/img/image-20210214122544157.png" alt="image-20210214122544157" style="zoom:33%;" />

补充：其实这样做有bug，就是假如x和y相同（也就是说假如相同地址的话），做XOR会把值丢失。因此需要在做操作之前，先判断x是否等于y

```c++
if (x != y) {
  x ^= y;
  y ^= x;
  x ^= y;
}
```

更优雅的写法：

```c++
(x == y) || ((x ^= y), (y ^= x), (x ^= y))
```



##### 在底层方面的应用

1. 判断`if (x != y)`，本质上是判断`if (x ^ y != 0)`

   因为减法是一个比异或操作复杂得多的操作（设计减法器并不容易）

2. 清零

   ```assembly
   xor same, same ; 两个地址相同，清零
   xor reg, reg ; 也可以对寄存器做
   ```

   

##### 用在对称加密领域

密文和密钥做异或操作，生成加密信息

LeetCode 1611

<img src="../../../../学习/笔记合集/img/image-20210214124517956.png" alt="image-20210214124517956" style="zoom:50%;" />



##### s异或双向链表

https://www.linuxjournal.com/article/6828



#### 找相邻的trick

> 0-1 2-3 4-5 这样的是一对

方法：x ^ 1

当 x 是偶数，则其二进制的末尾是 0，所以 x ^ 1 将其二进制的末尾改成 1，于是得到了x的对象 x + 1。
当 x 是奇数，则其二进制的末尾是 1，所以 x ^ 1 将其二进制的末尾改成 0，于是得到了x的对象 x - 1。



