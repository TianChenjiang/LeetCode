#### 判断质数：

```c++
bool isPrime(int num) {
  if (num <= 1) return false;
  if (num == 2) return true;
  for (int i = 2; i * i <= num; i++) { //注意这里能取等号
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}
```



#### 买股票问题：

只允许一次交易：遍历更新最小值，并取最大收益即可

不限制交易次数：遍历，只要能产生收益就加进来，返回累加和

限制交易次数：

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<int> sell(k+1,0);
        vector<int> buy(k+1,INT_MIN);
        for(int price : prices)
        {
            for(int i = 1;i <= k; i++) {
                buy[i] = max(buy[i],sell[i-1] - price);
                sell[i] = max(sell[i],buy[i] + price);
            }
        }
        return sell[k];
    }
};
```

注：内层循环以k=2比较好理解：

b1 = max(b1, -p);
s1 = max(s1, b1 + p);
b2 = max(b2, s1 - p);
s2 = max(s2, b2 + p);

这里的s1相当于sell[i-1]，b2相当于buy[i]，用自然语言解释就是(b2)是取b2和(前一次交易卖的利润-当前price)的最大值，s2就是取sell2和上一次买的股票加上以当前价格卖出的最大值

参考：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1).

限制最大交易次数：

直接令最大交易次数`k = min(k, n/2)`即可 



-

#### 滑动窗口问题

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

> 以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。
>















