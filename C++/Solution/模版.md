#### 二分法









#### 动态规划

记忆化递归：自顶向下（大问题 -> 小问题）也就是从目标求起

动态规划：自底向上（一般来说，写出记忆化递归，就能转成动态规划）

[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/fu-xue-ming-zhu-cong-ji-yi-hua-di-gui-tu-rqwy/)









#### 背包问题

https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85

分为三类

- 组合问题
  - 【377】 【494】 【518】
  - `dp[i] += dp[i-num]`
  - 需要考虑是否结果元素中的顺序问题
- True False 问题
  - 【139】 【416】
  - `dp[i] = dp[i] || dp[i-num]`
- 最大最小问题
  - 【474】 【322】
  - `dp[i] = min(dp[i], dp[i-num]+1)` or `dp[i] = max(dp[i], dp[i-num]+1)`

注意事项：

0-1背包 vs 完全背包 ： 元素是否可以重复使用

背包问题技巧：

（[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/)）

- 0-1背包

  ```c++
  for (int num : nums) {
    for (int i = target; i > num - 1; i--)
  }
  ```

- 完全背包

  ```c++
  for (int num : nums) {
    for (int i = num; i < target + 1; i++)
  }
  ```

- 组合问题且考虑元素顺序

  ```c++
  for (int i = 1; i < target+1; i++) {
    for (int num : nums) {
      
    }
  }
  ```

  

#### 判断质数：

```c++
bool isPrime(int num) {
  if (num <= 1) return false;
  if (num == 2) return true;
  for (int i = 2; i * i <= num; i++) { //注意这里能取等号
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}
```



#### 买股票问题：

只允许一次交易：遍历更新最小值，并取最大收益即可

不限制交易次数：遍历，只要能产生收益就加进来，返回累加和（一天内可以买或者卖）

限制交易次数：

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<int> sell(k+1,0);
        vector<int> buy(k+1,INT_MIN);
        for(int price : prices)
        {
            for(int i = 1;i <= k; i++) {
                buy[i] = max(buy[i],sell[i-1] - price);
                sell[i] = max(sell[i],buy[i] + price);
            }
        }
        return sell[k];
    }
};
```

注：内层循环以k=2比较好理解：

b1 = max(b1, -p);
s1 = max(s1, b1 + p);
b2 = max(b2, s1 - p);
s2 = max(s2, b2 + p);

这里的s1相当于sell[i-1]，b2相当于buy[i]，用自然语言解释就是(b2)是取b2和(前一次交易卖的利润-当前price)的最大值，s2就是取sell2和上一次买的股票加上以当前价格卖出的最大值

参考：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1).

限制最大交易次数：

直接令最大交易次数`k = min(k, n/2)`即可 



-

#### 滑动窗口问题

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

注意：内循环和外循环都是：先更新sum/res，再更新指针

> 以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

ps：记录一下，https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/，没有看懂

![image-20210205194837544](../../../../学习/笔记合集/img/image-20210205194837544.png)

例：LeetCode424

> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
>
> 注意：字符串长度 和 k 不会超过 104。
>
> ```
> 输入：s = "ABAB", k = 2
> 输出：4
> 解释：用两个'A'替换为两个'B',反之亦然。
> ```

```c++
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2) {
        return p1.second < p2.second;
    }

    int characterReplacement(string s, int k) {
        int l = 0, r = 0, n = s.size();
        int res = 0, maxCnt = 0;
        int counts[26];
        memset(counts, 0, sizeof(counts));
        while (r < n) {
            counts[s[r] - 'A']++;
            // maxCnt = max_element(m.begin(), m.end(), cmp)->second;
            maxCnt = max(maxCnt, counts[s[r] - 'A']);
            while (r - l + 1 - maxCnt > k) {
                counts[s[l] - 'A']--;
                l++;
            }
            res = max(res, r - l + 1);
            r++;
        }
        return res;
    }
};
```



例：LeetCode 1004

关键是做题意的转换

**最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度**  -> 找一个包含K个0的最长子数组



滑动窗口题目简单版本：

某些简单题目，比如最大连续1的个数，这种不需要用双指针，将l记录非0数字，r向右移动即可



一些变式：

【LeetCode 220】

滑动窗口来保存所有下标满足条件的元素

比较特殊的点是需要用一个有序的数据结构来保存，可以选set、multiset、map

由于有有序性，因此可以用lower_bound查看是否存在这样的元素，只要存在，那肯定符合题意

```c++
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
      int n = nums.size();
      int l = 0, r = 0;
      map<long long, int> m;
      while (r < n) {
        if (r - l > k) {
          m.erase(nums[l++]);
        }
        auto it = m.lower_bound((long long)nums[r] - t);
        if (it != m.end() && abs(it->first - nums[r]) <= t) return true;
        m[nums[r]] = r;
        r++;
      }
      return false;
    }
};
```





#### 盛雨水问题

LeetCode 11 

`res = max(res, 短板 * 板子之间距离)`

需要注意的就是移动左指针，还是右指针

因为板子之间距离必然减小，所以只有移动短板才可能变大，移动长板的话，那结果肯定小于等于原来的res

https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/fu-xue-ming-zhu-mian-xiang-lie-de-ji-sua-6uqr/



#### 双指针问题

【LeetCode 26 80】

此类问题的关键是明确指针的含义。

以80为例，slow表示是即将放置元素的位置，fast是向后遍历的元素。

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 2, n = nums.size();
        if (n <= 2) return n;
        for (int fast = 2; fast < n; fast++) {
            if (nums[slow-2] != nums[fast]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
};
```







#### 位运算

&和&&区别：

&&和||的两边只能是bool类型

&和|既可以逻辑运算，也可以位运算；也就是说对bool类型直接逻辑运算，对int整型做按位与



【重要】判断mask第i位是否为0的方法：

```c++
if (mask & (1 << i))
```

判断mask最低位是否为0的方法：

if (mask & 1 == 0)

让mask第i位赋值为1的方法：

```c++
mask |= (1 << i)
```



相关题目：

【LeetCode190】

【LeetCode 78】

这个题目也就是相当于求出 0 ～ 111111的全排列

左移几位就是往后面补几个0

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
      vector<vector<int>> res;
      vector<int> vec;
      int n = nums.size();
      
      for (int mask = 0; mask < (1 << n); mask++) { // mask < 1000
        vec.clear();
        for (int i = 0; i < n; i++) {
          // 判断第i位是否为1
          if (mask & (1 << i)) vec.push_back(nums[i]); // mask=111 i=2 -> 111 & 100
        }
        res.push_back(vec);
      }
      
      return res;
    }
};
```



【LeetCode338】

计算某个数字的二进制表示有多少个1

- 普通方法：

```c++
int num = 2, cnt = 0;
while (num > 0) { //num等于0已经要结束了
  cnt += num & 1;  //这个是判断最低位是否为1
  num >>= 1;
}
```

- 特殊方法：

假如要求一连串的，比如0到n的数字各有多少；有两种方法：

```c++
int num = 10;
vector<int> ans(num+1);
for (int i = 0; i <= num; i++) {
  if (i % 2 == 0) ans[i] = ans[i/2]; //比如2和4，4只是2在低位补0，总1不变
  else ans[i] = ans[i-1] + 1; //奇数的话等于离它最近的偶数+1
}
```

另一种特殊思路

> ```
> i    binary '1'  i&(i-1)
> 0    0000    0
> -----------------------
> 1    0001    1    0000
> -----------------------
> 2    0010    1    0000
> 3    0011    2    0010
> -----------------------
> 4    0100    1    0000
> 5    0101    2    0100
> 6    0110    2    0100
> 7    0111    3    0110
> -----------------------
> 8    1000    1    0000
> 9    1001    2    1000
> 10   1010    2    1000
> 11   1011    3    1010
> 12   1100    2    1000
> 13   1101    3    1100
> 14   1110    3    1100
> 15   1111    4    1110
> ```

二进制中1的个数也就是 i & (i-1)中的数+1，这样就形成了递推式

```c++
res[i] = res[i & (i-1) + 1]
```





#### 前缀和问题

##### 一维前缀和

```c++
for (int i = 1; i < n; i++) {
  preSum[i] = preSum[i-1] + nums[i];
}
```



##### 二维前缀和



理解：

<img src="../../../../学习/笔记合集/img/image-20210302102731472.png" alt="image-20210302102731472" style="zoom:33%;" />

> S(O,D) = S(O,C) + S(O,B)-S(O,A)

```c++
vector<vector<int>> preSum;
preSum.resize(row+1, vector<int>(column+1, 0)); //这里设置比原有的矩阵多一行一列，是为了让(0,0)也可求

//预处理求前缀和
for (int i = 0; i < row; i++) {
  for (int j = 0; j < column; j++) {
    preSum[i+1][j+1] = preSum[i][j+1] + preSum[i+1][j] - preSum[i][j] + matrix[i][j];
  }
}
```

<img src="../../../../学习/笔记合集/img/image-20210302103755376.png" alt="image-20210302103755376" style="zoom:33%;" />

> S(A,D) = S(O,D) - S(O,E) - S(O,F) + S(O,G)

```c++
// 求(row1, column1)到(row2, column2)的和
return preSum[r2+1][c2+1] - preSum[r2+1][c1] - preSum[r1][c2+1] + preSum[r1][c1]
```

补充：这里因为用了辅助行，(r2,c2)对应的是(r2+1,c2+1)



#### 单调栈问题 - 处理前后<u>元素之间的大小关系</u>

```c++
insert x;
while !st.empty() && st.top() < x :
	st.pop();
st.push(x);
```

s元素出栈的时机：不再单调

单调栈的性质：

- 单调栈中的元素具有单调性
- 递增（减）栈可以找到元素左右两侧第一个比自己小（大）的元素

【LeetCode 503】

题目的要求是找到数组中每个数字的下一个最大的元素；暴搜的话，如果处理类似[6,5,4,3,9]这种数组的时候，数组中递减的部分的下一个最大的元素相同，可以一并返回

```c++
vector<int> nextGreaterElements(vector<int>& nums) {
  int n = nums.size();
  vector<int> res(n, -1);
  stack<int> st;
  for (int i = 0; i < n * 2; i++) {
    int num = nums[i % n];
    while (!st.empty() && nums[st.top()] < num) {
      res[i % n] = num;
      st.pop();
    }
  }
  return res;
}
```

【LeetCode 456】

132模式（贪心的解读：1尽可能小，2尽可能大）

暴力解法 ：

$$O(N^2)$$ 有点贪心的思想，遍历数组时候，以132模式中的3为关注点，左边维护一个3左边数组的最小值，右边通过暴力搜索一个比3小，比1大的一个数字

单调栈：

问题的突破口是132模式中的2，也就是第三个数字，因为第一个数字是找最小，中间是最大，第三个数字的限制比较多。

其实2就是要**<u>找到比3小的最大元素</u>**，因此建立一个单调栈比较合适

因此从后往前遍历，建立一个递减栈，并且栈中的数字都是大于第三个数字的，一直从后往前遍历，如果碰到破坏栈中元素顺序，那么把里面的元素pop出来，最后一个被pop出来的元素，就是比3小的最大元素，然后把它赋值给2。

同时遍历的过程中，如果发现如果nums[i] < third，那么这说明找到了那个最小元素，也就是1。（也可以提前计算好



举例：

[2, 4, 2, 3, 5]

从后往前遍历，栈中的元素从底向上是 5 3 2，遇到4后，弹出2，3，3就是比模式132中3小的最大元素，那么将“2”赋值为3，停止while，然后往栈里压入4，再往前遍历，2小于3，那么[2,4,3]符合题意

```c++
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int third = INT_MIN;
        stack<int> st; //递减栈，栈中的元素均大于third
        for (int i = nums.size()-1; i >= 0; i--) {
            if (nums[i] < third) return true;
            while (!st.empty() && st.top() < nums[i]) {
                third = st.top(); st.pop();
            }
            st.push(nums[i]);
        }
        return false;
    }
};
```



[参考](https://jjaychen.me/programming/monotone-stack)

两种题型：

- 单向查找
- 双向查找

相关题目：





#### 回溯 - 适合用于搜索一个问题<u>所有的解</u>

[LeetCode讲解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

回溯和DFS的思想类似，不撞南墙不回头

> DFS，递归，栈 都是后进先出

回溯 vs dp：

- dp只要求求出最优解，但不关心最优解对应的具体解（比如说dp[i] = max(dp[i-1], dp[i-2]) 只知道最优解是dp[i]，但不要求过程）；适合用于评估一个方案的效果
- 回溯可以搜索到所有的方案，本质是一个遍历算法

回溯常用模版：

```c++
res = []
path = []

def backtrack(未探索区域, res, path):
    if 未探索区域满足结束条件:
        res.add(path) # 深度拷贝
        return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop() //我们从始至终只用了一个变量 path，所以当对 path 增加一个选择并 backtrack 之后，需要清除当前的选														择，防止影响其他路径的搜索

```

相关题目：【LeetCode131】

本题需要我们把字符串分成一系列的回文子串，按照模板，我们的思路应该是这样的：

未探索区域：剩余的未搜索的字符串 s；
结束条件：s 为空；
未探索区域当前可能的选择：每次选择可以选取 s 的 1 ~ length 个字符，cur = s[0...i]cur=s[0...i]；
当前选择符合要求：cur 是回文字符串 isPalindrome(cur)；
新的未探索区域：s 去除掉 cur 的剩余字符串，s[i + 1...N]s[i+1...N]。

【LeetCode78，LeetCode90】





#### LIS问题

##### 动态规划：$$O(N^2)$$

dp[i]表示以i结尾的最长递增子序列长度，递推式是`dp[i] = max(dp[i], dp[j]+1)`

```c++
int lengthOfLIS(vector<int>& nums) {
  int res = 0, n = nums.size();
  vector<int> dp(n, 1);
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = max(dp[i], dp[j]+1);
      }
    }
    res = max(res, dp[i]);
  }
}
```

##### 贪心 + 二分： $$O(NlgN)$$

https://blog.csdn.net/u012505432/article/details/52228945



##### 二维LIS问题

【LeetCode 354】



#### 表达问题

总结：

无括号：遇到乘除立即算，遇到加减先入栈（遇到乘除，栈顶元素和当前元素进行运算，而如果是加减，把数字入栈或者取反后入栈）

注意：C++和Java的地板除法是向零取整 eg: -3 / 2 = -1

##### 类型1：加减法，括号

没有运算优先级的比较

遇到左括号的时候，把当前结果和左括号前的符号压入栈，然后把括号里的式子当成一个完整的式子来计算，遇到右括号的时候，给括号内的运算结果加上符号，然后加上栈里弹出来的值

```c++
stack<int> st;
int res = 0, sign = 1;
for (int i = 0; i < s.size(); i++) {
  char chr = s[i];
  switch(chr) {
    case '+':
      sign = 1;
    	break;
    case '-':
      sign = -1;
      break;
    case '(':
      st.push(res);
      st.push(sign);
      res = 0;
      sign = 1;
      break;
    case ')':
      res *= st.top(); st.pop();
      res += st.top(); st.pop();
      break;
    case ' ':
      break;
    default:
      int num = 0;
      while (i < n && chr >= '0') {
        num = num * 10 + chr - '0';
        i++;
      }
      res += sign * num;
      i--;
  }
  return res;
}
```

另一种思路，直接把括号内的部分当成一个式子来算，也就是用递归

```c++
class Solution {
public:
    int calculate(string s) {
        int res = 0, num = 0, sign = 1, n = s.size();
        for (int i = 0; i < n; ++i) {
            char c = s[i];
            if (c >= '0' && c <= '9') {
                num = 10 * num + (c - '0');
            } else if (c == '(') {
                int j = i, cnt = 0;
              	for (; i < n; i++) {
                  if (s[i] == '(') cnt++;
                  if (s[i] == ')') cnt --;
                  if (cnt == 0) break;
                }
              num = calculate(s.substr(j+1, i-j+1));
            }
            if (c == '+' || c == '-' || i == n - 1) {
                res += sign * num;
                num = 0;
                sign = (c == '+') ? 1 : -1;
             } 
        }
        return res;
    }
};
```

##### 类型二：加减乘除【LeetCode227】





##### 类型三：加减乘除括号【LeetCode772】









#### 空间有限制的处理方法d

不借用辅助的数据结构，一般是用参数所提供的数据结构来进行

有一个原地算法，

想到的几种处理思路：

- 借助int是32位，可以用位运算

- 借助参数数组，比如可以用矩阵的第一行第一列作为存储，再用常数变量存储第一行第一列

  - 【LeetCode 73】

    空间复杂度：O(M+N) 我的一般思路是用两个数组，维护有哪些行和列有0，然后再遍历一遍matrix置0

    空间复杂度：O(1) 用两个变量记录第一行和第一列是否有0，然后再用第一行第一列记录其他行和列的情况

- 通过多次swap

  - 将一个数组逆序，就可以不断做交换而达成目标

  ```c++
  for (int i = 0; i < int(n / 2); i++) {
    swap(array[i], array[n-i-1]);
  }
  ```

  

#### 数字类型题

丑数：只包含质因数 `2`、`3` 和/或 `5` 的正整数。

【LeetCode 264】

可以用三指针做法，注意规律就是后面的丑数就是前面的丑数再乘2/3/5

因此每次将三者的最小值加入结果集合即可

Ps: 另外一种方法是用优先队列自然排序，不过每次遍历的时候需要先判断是否队列头有重复元素（这个没懂）

https://www.cnblogs.com/grandyang/p/4743837.html



#### 排序类问题

类型1：组成最大数

【LeetCode 179】

```c++
sort(strs.begin(), strs.end(), [](string &a, string &b) {
  return a + b > b + a;
})
```

<u>注意点是最后需要判断是否首位为0</u>



#### 前缀树

【LeetCode 208】

三个性质：

根节点没有字符，除根节点外每个节点包含一个字符

根节点某个节点，字符连接起来就成为节点对应的字符串

每个节点的字节点包含的字符不同

```c++
class TrieNode {
public:
    vector<TrieNode*> children;
    TrieNode() : children(26) { //注意这里的初始化只能放在构造方法的列表里
        for (TrieNode* node : children) {
        node = nullptr; //这里可能有空子节点，所以是nullptr
        }
    }
    bool isWord = false;
};

class Trie {
private:
    TrieNode* root;
public:
    /** Initialize your data structure here. */
    Trie() {
        root = new TrieNode(); //注意一下指针初始化的方式，这里是需要初始化实际的节点，所以用创建对象
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        TrieNode* p = root;
        for (char c : word) {
            int i = c - 'a';
            if (!p->children[i]) p->children[i] = new TrieNode();
            p = p->children[i];
        }
        p->isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        TrieNode* p = root;
        for (char c : word) {
            int i = c - 'a';
            if (!p->children[i]) return false;
            p = p->children[i];
        }
        return p->isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        TrieNode* p = root;
        for (char c : prefix) {
            int i = c - 'a';
            if (!p->children[i]) return false;
            p = p->children[i];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

实际应用：自动补全单词，比如输入法



