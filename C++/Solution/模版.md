### 贪心

总结一些常见的贪心：

【LeetCode 1881】好题

我的思路是找出最大的绝对值差，然后对它进行替换，但不一定能对这个最大值进行替换，比如**[1,28,21] [9,21,20]**，如果把1换成别的反而会。

正确的思路是，针对每个绝对值差，看能做出多大的优化，找出那个最大的优化值

```c++
class Solution {
public:
    int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(); int res = 0;
        int MOD = pow(10, 9) + 7;
        vector<int> vec(nums1);
        sort(vec.begin(), vec.end());
        int maxExange = 0; //比起某个位置的diff，在交换后能额外小多少
        for (int i = 0; i < n; i++) {
            int diff = abs(nums1[i] -  nums2[i]);
            res = (res + diff) % MOD;
            //找最接近nums2[i]的nums1
            int index = lower_bound(vec.begin(), vec.end(), nums2[i]) - vec.begin();
            //min (>= nums2[i]) 也就是it!=nums.end()
            if (index < n) maxExange = max(maxExange, diff - (vec[index] - nums2[i])); 
            // nums2[i]大的情况 也就是it!=nums.begin()
            //这里执行了上面那条，下面也需要执行
            if (index > 0)  maxExange = max(maxExange, diff - (nums2[i] - vec[index-1]));  
        }
        return (int)(res - maxExange + MOD) % MOD; //注意取余数的时候前面需要加一个MOD
    }
};
```

【LeetCode1877】

排序后把每一对的最大最小组合起来，求出这些组合的最大值，即为题目所求最小值

需要复习的好题 ：

738 [Monotone Increasing Digits](https://leetcode-cn.com/problems/monotone-increasing-digits/)

402 [Remove K Digits](https://leetcode-cn.com/problems/remove-k-digits/)  用了单调栈思想

659 [Split Array into Consecutive Subsequences](https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/)





### 二分法

减治：每次排除不符合要求的元素，搜索空间持续减少

标准模版：(**当目标元素有多个的时候**)

在[l, r)上找目标元素

```c++
int l = 0, r = nums.size();
while (l < r) { //相等就退出
  int mid = l + (r - l) / 2; //也可以 long mid = (long)l + r >> 1
  if (target < nums[mid]) {
    r = mid; //说明答案在[l, mid)区间 注意r也是取不到的
  } else {
    l = mid + 1; //说明答案在(mid, r)，也就是[mid + 1, r)区间，根据数学归纳法可以排除掉A[mid]
  }// while的出口是大于target最小元素 查找成功不能提前终止。最后返回的l相当于upper_bound
  return --l; //此时 l == r，区间缩为一个点，l-1是不大于target的最大元素
  // 有多个命中元素，能返回秩最大值，查找失败，能返回失败的位置
}
```

最后将数组分为两个部分，左边满足<= target  target > 右边

最后循环结束后，l是在有半部分的第一个元素，l-1是左半部分最后一个元素

另一种写法：

```c++
int l = 0, r = nums.size() - 1;
while (l <= r) {
  int mid = l + (r - l) / 2;
  if (nums[mid] == target) return mid;
  if (nums[mid] > target) r = mid - 1;
  else if (nums[mid] < target) l = mid + 1;
}
return -1;
```



<img src="../../../../学习/笔记合集/img/image-20210716100510835.png" alt="image-20210716100510835" style="zoom:33%;" />

网上总结关于二分的几种类型 https://www.cnblogs.com/grandyang/p/6854825.html

总结的很好：https://segmentfault.com/a/1190000016825704





深度思考：

二分的本质不是单调性，而是**二段性**

满足二段性的特征就可以使用二分法，不一定需要严格符合二分的要求

二段性也不仅仅是**满足/不满足**进行二分，**一定满足/不一定满足**也可以二分

【LeetCode 152】

这道题的二段性的含义：在以mid为分割点的数组中，根据nums[mid+1]和nums[mid]的大小关系，可以确定一段必然有解，另一段可能有解，可能无解

因此选择一段进行二分，能保证区间内一定有峰值

简单的理解：如果nums[mid - 1] < nums[mid]，那么说明mid处可能为峰值，而mid-1处肯定不是峰值，因此在右半边继续找（需要注意因为要取到mid-1，所以l的初始值设为1）

严格证明：https://leetcode-cn.com/problems/find-peak-element/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-qva7v/

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size(), l = 1, r = n;
        if (n == 1) return 0;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid - 1] < nums[mid]) l = mid + 1;
            else r = mid;
        }
        return --l;
    }
};
```

或者

由于下面要取mid+1，这种解法r最大能取到n-2

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size(), l = 0, r = n - 1;
        if (n == 1) return 0;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > nums[mid + 1]) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
```





【LeetCode 852】找出极值点 满足/不满足的二分

二段性：峰值左侧满足递增，右侧不满足，右侧满足递减，左侧不满足

```c++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int l = 0, r = arr.size();
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid - 1] < arr[mid]) {
                l = mid + 1;
            } else r = mid;
        }
        return --l;
    }
};
```



相关题目【LeetCode 274】【LeetCode 275】

【LeetCode 33】







### 动态规划

非常非常非常好的归纳：https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85（在参考文件夹有拷贝）

记忆化递归：自顶向下（大问题 -> 小问题）也就是从目标求起

动态规划：自底向上（一般来说，写出记忆化递归，就能转成动态规划）

[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/fu-xue-ming-zhu-cong-ji-yi-hua-di-gui-tu-rqwy/)

经典好题：

容易出错的一道题：

【剑指Offer 42】

这道题容易在变量的初始值上出错，比如res的取值不能取0，因为当数组全部为负数，结果是小于res的，但也不能取INT_MIN，因为当数组只有一个元素的时候，res不会被更新，综上，res取nums[0]最合适

总结：实际做题的时候，需要把几种边界情况带进去考虑，只有一个元素（0，1，-1），全为负数

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int res = nums[0], cur = nums[0];
        for (int i = 1; i < n; i++) {
          cur = max(cur + nums[i], nums[i]);
          res = max(cur, res);
        }
        return res;
    }
};
```



##### 【403】青蛙过河

关键点是在每块石头上的关注点是当前是第几块石头，上一个是怎么来的，因此把这两个作为一个状态，也就是`dp[i][j]`

表示在第i块石头上，并且上一次的跳跃距离是j

因此只需要一个二重遍历，当走到第i块石头，再一步步往回遍历，看是否能从j石头跳到这里，判断的标准是

`dp[i][k] = dp[j][k-1] || dp[j][k] || dp[k+1] `

这时候如果i==n-1并`dp[i][k]`为true的话，那说青蛙能跳过来



需要注意的就是可以进行剪枝优化：

- 在第i块石头上，离它最近的石头的距离不能超过i，因为在第i-1的石头上，最多能跳（i-1) +1 
- 两个石头i和j距离超过j+1时，青蛙必定无法到达终点

```c++
class Solution {
public:
    bool canCross(vector<int>& stones) {
        // dp[i][j]表示当前第i块石头，是上一次跳的距离为j跳过来的
        int dp[2001][2002];
        memset(dp, 0, sizeof(dp));
        int n = stones.size();
        dp[0][0] = 1; //这个是因为第一步只能跳一个单位
        for (int i = 1; i < n; i++) {
            if (stones[i] - stones[i-1] > i) return false;
        }
        // 最后需要判断 dp[i-1][k]是否为true
        for (int i = 1; i < n; i++) {
            for (int j = i - 1; j >= 0; j--) {
                int dis = stones[i] - stones[j];
                if (dis > j + 1) break; //从j跳到i，最多只可能跳j+1，距离大于j+1，那必不可能
                dp[i][dis] = dp[j][dis-1] || dp[j][dis] || dp[j][dis+1];
                if (i == n-1 && dp[i][dis]) return true;
            }
        }
        return false;
    }
};
```



##### 打家劫舍（不能取到连续元素的一类问题）

变式：【LeetCode 740】通过将数组的相同元素进行聚合，就转换为打家劫舍问题

```c++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int aggregateNums[10001], dp[10001];
        memset(aggregateNums, 0 ,sizeof(aggregateNums));
        int cnt = 0;
        for (int i = 0; i < nums.size(); i++) {
            aggregateNums[nums[i]] += nums[i];
            cnt = max(cnt, nums[i]);
        }
        //dp[i]表示数字i前获得的最大点数，需要注意的就是这里的两个数组都当成hash来用了，下标也对应着元素Id
        dp[0] = 0, dp[1] = aggregateNums[1];
        for (int i = 2; i <= cnt; i++) {
            dp[i] = max(dp[i-1], dp[i-2] + aggregateNums[i]);
        }
        return dp[cnt];
    }
};
```



#### 打印机问题

【LeetCode 664】

这个题需要注意的是**倒序遍历**，因为需要确保`dp[i][k]` 和 `dp[k+1][j]`都已经被计算

```c++
class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        int dp[101][101];
        // dp[i][j]表示i到j区间内的打印次数
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) dp[i][j] = dp[i][j-1];
                else {
                    // i到j需要分为两部分，取最小值
                    int tmp = INT_MAX;
                    for (int k = i; k < j; k++) { //k从i开始取的好处是，假如i = j - 1，不用做特殊处理
                        tmp = min(tmp, dp[i][k] + dp[k+1][j]);
                    }
                    dp[i][j] = tmp;
                }
            }
        }
        return dp[0][n-1];
    }
};
```



#### 与图论相关的DP

【LeetCode 1269】

关键在于dp数组的定义，`dp[i][j]`表示经过i个步骤后到达索引j的方案

然后可能不动，向左，向右到达当前状态

（有个问题是好像直接用正常的数组就会overflow）





【LeetCode 576】

这道题已经声明了结果可能非常大，因此不适合用递归

DP的定义是`dp[k][i][j] 表示初始状态在(i,j)，经过K步能出界的次数`

```c++
class Solution {
public:
    int MOD = pow(10, 9) + 7;
    const int K = 51, M = 51, N = 51;
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        vector<vector<int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        int dp[K][M][N];
        memset(dp, 0, sizeof(dp));
        for (int k = 1; k <= maxMove; k++) {
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    long long up = (j == 0) ? 1 : dp[k-1][i][j-1];
                    long long down = (j == n-1) ? 1 : dp[k-1][i][j+1];
                    long long left = (i == 0) ? 1 : dp[k-1][i-1][j];
                    long long right = (i == m-1) ? 1 : dp[k-1][i+1][j];
                    dp[k][i][j] = (up + down + left + right) % MOD;
                }
            }
        }
        return dp[maxMove][startRow][startColumn];
    }
};
```

这道题也可以用BFS的思路进行求解TODO

```c++
class Solution {
public:
    int findPaths(int m, int n, int N, int i, int j) {
        int res = 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[i][j] = 1;
        vector<vector<int>> dirs{{0,-1},{-1,0},{0,1},{1,0}};
        for (int k = 0; k < N; ++k) {
            vector<vector<int>> t(m, vector<int>(n, 0));
            for (int r = 0; r < m; ++r) {
                for (int c = 0; c < n; ++c) {
                    for (auto dir : dirs) {
                        int x = r + dir[0], y = c + dir[1];
                        if (x < 0 || x >= m || y < 0 || y >= n) {
                            res = (res + dp[r][c]) % 1000000007;
                        } else {
                            t[x][y] = (t[x][y] + dp[r][c]) % 1000000007;
                        }
                    }
                }
            }
            dp = t;
        } 
        return res;
    }
};
```









#### 区间DP 问题

每个区间的最优值都是由更小区间的最优值得到的，属于分治思想

本质：把问题划分为更小的区间，**枚举小区间的组合**，求合并后的最优值

从小到大枚举区间长度和枚举区间的左端点

##### 模版

`dp[i][j]`表示区间[i,j]，每次将这部分区间用k分为[i, k]和[k+1, j]两部分，也就是完成对小区间的枚举

基本流程：

1. 从小到大枚举长度len
2. 枚举左端点l，然后根据l和len计算r = l + len - 1
3. 通过状态转移求`dp[l][r]`

```c++
for (len = 1; len <= n; len++) {
  for (int l = 0; l < n; i++) {
    int r = l + len - 1;
  }
}
```



【LeetCode 516】

从小区间的回文状态可以推导至大区间的回文状态





【LeetCode877】

需要注意的是题解中令石头的下标从1开始，这个做法比较巧，可以避免有些步骤中在取前一块石头时候，如果正好是第一块石头，则会出现错误

转移方程如下：定义`dp[i][j]`表示在[i, j]区间中，在最优策略下，先手和后手的最大差值

- 取的是左边的石头，差值变为 `piles[l-1] - dp[l+1][r]` ，`dp[l+1][r]`表示后手在[l+1,r]区间内取石头
- 取的是右边的石头，差值变为 `piles[r-1] - dp[l][r-1]` ，`dp[l+1][r]`表示后手在[l+1,r]区间内取石头

由于都是最优策略，因此选择二者的最大值

如果最后`dp[1][n]`大于0，那么表示先手和后手的差值为正，也就是先手胜

```c++
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int n = piles.size();
        vector<vector<int>> dp(n + 2, vector<int>(n + 2));
        // dp[i][j]表示在区间[i,j]中，先手和后手的最大差值
        for (int len = 1; len <= n; len++) {
            for (int l = 1; l + len - 1 <= n; l++) {
                // r - l + 1 = len
                int r = len + l - 1;
                int choice1 = piles[l-1] - dp[l+1][r]; //左边选石头
                int choice2 = piles[r-1] - dp[l][r-1];
                dp[l][r] = max(choice1, choice2);
            }
        }
        return dp[1][n];
    }
};
```



#### 状态压缩DP

一般数据所给范围长度比较小的时候可以使用

【LeetCode 526】在位运算部分



#### 数位DP

典型场景：题目要求在[a,b]区间内符合条件的数值有多少

做法：实现一个dp(int  x), 用来查询[0, x]有多少复合条件的数值，然后用容斥原理求出解[a, b]的个数，为dp[b] - dp[a-1]

通常从高位到低位进行求解

【LeetCode 600】

较为特殊的位运算做法在位运算部分

一种更普适性的做法：

`dp[i][j]`表示长度为i的二进制串，最高位为j(j = 0 or 1)，符合题意的个数

```java
class Solution {
    static int N = 50;
    // f[i][j] 为考虑二进制长度为 i，而且最高位为 j（0 or 1）时的合法数个数
    static int[][] f = new int[N][2];
    static {
        f[1][0] = 1; f[1][1] = 2;
        for (int i = 1; i < N - 1; i++) {
            f[i + 1][0] = f[i][1];
            f[i + 1][1] = f[i][0] + f[i][1];
        }
    }
    int getLen(int n) {
        for (int i = 31; i >= 0; i--) {
            if (((n >> i) & 1) == 1) return i;
        }
        return 0;
    }
    public int findIntegers(int n) {
        if (n == 0) return 1;
        int len = getLen(n);
        int ans = 0, prev = 0;
        for (int i = len; i >= 0; i--) {
            // 当前位是 0 还是 1
            int cur = ((n >> i) & 1); 
            // 如果当前位是 1，那么填 0 的话，后面随便填都符合，将方案数累加
            if (cur == 1) ans += f[i + 1][0]; 
            // 出现连续位为 1，方案数被计算完了
            if (prev == 1 && cur == 1) break; 
            prev = cur;
            if (i == 0) ans++;
        }
        return ans;
    }
}
```





#### 排列组合问题

【LeetCode 552】

状态转移：

先不考虑A，首先求出以P和P或L结尾的数量

PorL[i]的更新：假如是P，那么也就是P[i]（刚刚更新过），假如是L，那么前一位是P 或者 前一位是L并且前前一位是P，也就是P[i-1] + P[i-2 ]

```c++
class Solution {
public:
    int MOD = pow(10, 9) + 7;
    int checkRecord(int n) {
        vector<long> P(n + 1), PorL(n + 1); //P[i]表示以P结尾的长度为i的排列数，后者表示P或者L
        long res = 0;
        P[0] = 1, PorL[0] = 1, PorL[1] = 2; 
        for (int i = 1; i <= n; i++) {
            P[i] = PorL[i-1]; //由于P没有限制，因此前一位可以是P或者L
            if (i > 1) PorL[i] = (P[i] + P[i-1] + P[i-2]) % MOD; 
        }
        res = PorL[n];
        for (int i = 0; i < n; i++) { //第i个位置变为A,把数组分为两部分，结果就等于两部分长度对应排列乘积
            res = (res + PorL[i] * (PorL[n - i - 1])) % MOD;
        }
        return res;
    }
};
```





#### 背包问题

判定：给定一些物品，从中进行选择，以达到最大价值或者特定价值

本质上是组合问题，因为被选定的物品之间没有关系，只需要选择，以达到全局最优或者特定状态

https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85

分为三类

- 组合问题
  - 【377】 【494】 【518】
  - `dp[i] += dp[i-num]`
  - 需要考虑是否结果元素中的顺序问题
- True False 问题
  - 【139】 【416】
  - `dp[i] = dp[i] || dp[i-num]`
- 最大最小问题
  - 【474】 【322】
  - `dp[i] = min(dp[i], dp[i-num]+1)` or `dp[i] = max(dp[i], dp[i-num]+1)`

注意事项：

0-1背包 vs 完全背包 ： 元素是否可以**重复使用**

背包问题技巧：

（[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/)）

- 0-1背包

  ```c++
  for (int num : nums) {
    for (int i = target; i > num - 1; i--)
  }
  ```

- 完全背包

  ```c++
  for (int num : nums) {
    for (int i = num; i < target + 1; i++)
  }
  ```

- 组合问题且考虑元素顺序

  ```c++
  for (int i = 1; i < target+1; i++) {
    for (int num : nums) {
      
    }
  }
  ```




一定需要明确背包问题的使用场景，这道题如果用背包的话可以做出来，但是会超时。

这道题只要排序后，采用贪心思想，取最前面的几个就可以了

换一种角度思考：

背包问题一般是解决两个维度相互牵制的问题，如背包容量和背包价值，比如选择重量最轻的放背包，但价值不会迅速增长，如果选择价值高的，但容量可能消耗的最多。所以只对某个维度做贪心的话，不是全局最优解。（应该对单位价值做贪心）



【LeetCode 1833】

而在这道题中，要求最大数量，而每个物品的贡献度都是1，优先选择价格低的能让剩余金额变多



##### 0-1背包大总结

复杂度 O(N * C)

最基本的问题描述：

在一个容量为n的背包，要用这个背包装下物品的价值最大，每个物品有两个属性，体积w和价值v

具体分析：

对于第i个物品，可能放入背包，也可能不放入

定义二维数组`dp[i][j]`表示：前i件物品，在体积<u>不超过j</u>的情况下能获得的最大价值

- 不放入的话：前i件的最大价值也就是前i-1的最大价值 也就是`dp[i][j] = dp[i-1][j]`
- 放入的话：还需要加上当前价值 `dp[i][j] += dp[i-1][j-coins[i-1]]`

```c++
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
  	vector<vector<int>> dp(N+1, vector<int>(W+1));
    for (int i = 1; i <= N; i++) {
      int value = values[i-1], weight = weights[i-1];
      for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i-1][j];
        if (j >= weight) dp[i][j] = max(dp[i][j], dp[i-1][j-weight] + value);
      }
    }
  	return dp[N][W];
}
```

几个写 代码层面的注意点：

- 外层遍历初始值是1，因为当前状态和前面状态有关
- 内部遍历的目的值应该能取等于号，比如这里的`j <= W`，因为dp数组的定义是不超过j
- 需要注意最后求的是方案数还是最大值，这个决定了状态转移方程是什么样的



利用滚动数组的方法优化：

由于第i个物品的状态只和i-1有关，因此可以对数组进行降维。但需要注意的是，内部遍历必须是倒序遍历。原因是假如正序遍历，会先计算`dp[i][0]` 一直到`dp[i][weight]`，这部分会把dp[i-1]的进行覆盖，等后面满足j >= weight条件后，会需要`dp[i-1][j-weight]`的值，正序的话这部分值已经被替换为`dp[i-1][j-weight]`，无法满足

```c++
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
  	vector<int> dp(W+1);
    for (int i = 1; i <= N; i++) {
      int value = values[i-1], weight = weights[i-1];
      for (int j = W; j >= 1; j--) {
        if (j >= weight) dp[j] = max(dp[j], dp[j-weight] + value);
      }
    }
  	return dp[N][W];
}
```



相关题目：

重要的是识别出题目可以转化为01背包问题，然后识别出相关的物品和限制

【LeetCode 494】

数学推导：

已知：

Sum(P) - Sum(N) = target

Sum = Sum(P) + Sum(N)



Sum(P) + Sum(N) - Sum(N) -Sum(N) = target

合并 Sum - 2*Sum(N) = target

最后得到 Sum(N) = (Sum - target) / 2

同理也可以找出Sum(P)和sum target之间的关系

通过数学推导可以转化为要在数组中找出一个子集，和恰好为sum/2的方案数

状态转移方程为 $$f[i][j] = f[i-1][j] + f[i-1][j-nums[i-1]]$$



需要注意的是先要排除不满足题意的条件`if (sum < target || (target + sum) % 2 != 0) return 0;` （因为必须都是整数，才能满足那个等式）

代码如下：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
      int n = nums.size(), sum = 0;
      sum = accumulate(nums.begin(), nums.end(), 0);
      // 找到一个子集，满足和恰好为(sum-target)/2
      int nTarget = (sum - target) / 2;
      if (sum < target || (sum - target) % 2 != 0) return 0;
      vector<int> dp(nTarget + 1);
      dp[0] = 1;
      for (int i = 1; i <= n; i++) {
        int num = nums[i-1];
        for (int j = nTarget; j >= num; j--) {
          dp[j] += dp[j - num];
        }
      }
      return dp[nTarget];
    }
};
```

【LeetCode 1049】

关键是如何转化为背包问题

【LeetCode 1449】

【LeetCode 879】

【LeetCode 474】



##### 完全背包问题

与01背包的区别就是元素是否能重复使用

状态转移方程：

$$dp[i][j] = max(dp[i-1][j],  dp[i-1][j-k*w[i]] + k*v[i])$$

一维优化：

$$dp[j] = max(dp[j],dp[j-w[i]] + v[i])$$ j

写代码的注意点：

- 注意题目是恰好还是不超过

  > 背包有「不超过」和「恰好」的状态定义，其实其只有初始化的不同。
  >
  > 从状态合法性出发考虑初始化即可。
  >
  > 我的代码里对「恰好」的定义体现在 f[0] = 0 其余为负无穷

- 内部遍历为正序

  (这样做的原因是将成本和价值进行抽象，然后进行换元法；有点类似于把多个一样的物品看作一种)

[参考](https://leetcode-cn.com/problems/coin-change-2/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv/)

【LeetCode 518】

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
      int n = coins.size();
      vector<vector<int>> dp(n+1, vector<int>(amount+1));
      dp[0][0] = 1;
      for (int i = 1; i <= n; i++) { //物品的遍历
        int coin = coins[i-1];
        for (int j = 1； j <= amount; j++) {  //目标金额的遍历
          for (int k = 1;  k * coin <= j; k++)   { //某个钱使用次数的遍历
            	dp[i][j] += dp[i-1][j-k*coin];
            }
        }
      }
      return dp[n][amount]
    }
};
```

通过换元优化法：

可以经过数学推导验证正确性，通俗理解就是将重复的多个物品看成一个整体

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
      int n = coins.size();
      vector<int> dp(amount+1);
      dp[0] = 1;
      for (int i = 1; i <= n; i++) { //物品的遍历
        int coin = coins[i-1];
        for (int j = coin； j <= amount; j++) {  //目标金额的遍历
          dp[j] +=  dp[j-coin];
        }
      }
      return dp[amount]
    }
};
```



【LeetCode1449】

两条规则：

- 数字位数越多越大
- 位数相同，则依次比较位数

具体的，先考虑「数值长度」问题，每个数字有相应选择成本，所能提供的长度均为 11。

问题转换为：有若干物品，求给定费用的前提下，花光所有费用所能选择的最大价值（物品个数）为多少。

每个数字可以被选择多次，属于完全背包模型。

当求得最大「数值长度」后，考虑如何构造答案。

根据规则二，应该尽可能让高位的数值越大越好，因此我们可以从数值 99 开始往数值 11 遍历，如果状态能够由该数值转移而来，则选择该数值。



>背包有「不超过」和「恰好」的状态定义，其实其只有初始化的不同。
>
>从状态合法性出发考虑初始化即可。
>
>我的代码里对「恰好」的定义体现在 f[0] = 0 其余为负无穷



#### 判断质数：

```c++
bool isPrime(int num) {
  if (num <= 1) return false;
  if (num == 2) return true;
  for (int i = 2; i * i <= num; i++) { //注意这里能取等号
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}
```



### DFS

【LeetCode1723】

暴搜：

```c++
class Solution {
public:
    int res = INT_MAX, n, _k;
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int work[13];
        memset(work, 0, sizeof(work));
        n = jobs.size(), _k = k;
        dfs(jobs, 0, work, 0);
        return res;
    }

    void dfs(vector<int>& jobs, int cur, int work[], int maxTime) {
        if (maxTime >= res) return;
        if (cur == n) {
            res = maxTime;
            return;
        }
        for (int i = 0; i < _k; i++) {
            work[i] += jobs[cur];
            dfs(jobs, cur+1, work, max(maxTime, work[i]));
            work[i] -= jobs[cur];
        }
    }
};
```

剪枝优化：

```c++
class Solution {
public:
    int res = INT_MAX, n, _k;
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int work[13];
        memset(work, 0, sizeof(work));
        n = jobs.size(), _k = k;
        dfs(jobs, 0, 0, work, 0);
        return res;
    }

  	// used 分配到第几个工人
    // work数组 工作情况 work[i] = a 表示i号工人工作量为a
    // cur 分配到第几个工作
    // maxTime 当前的最大时间
    void dfs(vector<int>& jobs, int used, int cur, int work[], int maxTime) {
        if (maxTime >= res) return;
        if (cur == n) {
            res = maxTime;
            return;
        }
        if (used < _k) {
            work[used] += jobs[cur];
            dfs(jobs, used+1, cur+1, work, max(maxTime, work[used]));
            work[used] -= jobs[cur];
        }

        for (int i = 0; i < used; i++) { //注意这里只遍历[0, used]
            work[i] += jobs[cur];
            dfs(jobs, used, cur+1, work, max(maxTime, work[i]));
            work[i] -= jobs[cur];
        }
    }
};
```

解析：

优化的关键在于加入if条件，表示先把工作优先分配给没有工作的人，原来的未优化版本的最差情况是所有工作都交给第一个工人

优化后：（这个题的大致目的是尽可能完成平均分配）

if表示分配给没有工作的人，后面的循环表示分配给已经有工作的人。if的分配不需要遍历，因为大家都没有工作时间，所以随便分配一个然后dfs就可以，而后面的循环，本身都有工作时间了，不同分配会有不同的结果，因此需要挨个遍历

<img src="../../../../学习/笔记合集/img/image-20210531114121940.png" alt="image-20210531114121940" style="zoom:33%;" />



### BFS

先生成的结点先扩展（因此能求到最短路径）

**<u>求极值的前提</u>：**结点到它可以扩展结点的距离都相同

##### 求极值两大方法：dp，BFS（迷宫遍历问题）

使用场景： **层次遍历，最短路径问题**

参考：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/

明确和DFS区别：都可以遍历树、图中的所有结点，能力没什么差别，但倾向于更好写，空间复杂度更小的DFS

DFS是递归遍历，BFS用队列遍历

DFS比较简洁，因为递归用了系统的栈





适合解决的问题：遍历树，图，统计无权图到达某个点的方案数（举例：【[LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/)】可以用DFS，BFS解决，也可以用DP解决）

BFS：

```c++
void BFS(TreeNode* root) {
  queue<TreeNode*> q({root});
  while (!q.empty()) {
    TreeNooe* cur = q.top(); q.pop();
    if (cur->left) q.push(cur->left);
    if (cur->right) q.push(cur->right);
  }
}
```

升级版：

<img src="../../../../学习/笔记合集/img/image-20210625120053272.png" alt="image-20210625120053272" style="zoom:33%;" />

```c++
void BFS(TreeNode* root) {
  queue<TreeNode*> q({root});
  while (!q.empty()) {
    int n = q.size(); //n表示这一层的所有结点
    for (int i = 0; i < n; i++) { //层次遍历的话，每个for循环是一层
      TreeNooe* cur = q.top(); q.pop();
    	if (cur->left) q.push(cur->left);
    	if (cur->right) q.push(cur->right);
    }
  }
}
```



![image-20210802165857742](../../../../学习/笔记合集/img/image-20210802165857742.png)



```c++
void BFS() {
  queue<int> q{{root}};
  unordered_set<int> st;
  while (q.empty()) {
    int n = q.size();
    for (int i = 0; i < n; i++) {
      int cur = q.front(); q.pop();
      
      if (cur == target) return;
      
      //这里可以对cur进行处理
      
      for (int x : cur.children) {
        if (st.count(x)) continue;
        q.push(x);
        st.insert(x);
      }
      
    }
  }
}
```



最短路径问题：

Dijkstra解决的是有权最短路径问题，BFS是无权最短路径

优化：

多源BFS，可以往队列里放多个初始结点，这样就是以多个结点开始BFS

总结：

BFS遍历的基础上记录每一层 -> 层序遍历 ->  层序遍历的基础上记录层数 -> 最短路径



> 层序遍历的一些变种题目：
>
> LeetCode 103. Binary Tree Zigzag Level Order Traversal 之字形层序遍历
> LeetCode 199. Binary Tree Right Side View 找每一层的最右结点
> LeetCode 515. Find Largest Value in Each Tree Row 计算每一层的最大值
> LeetCode 637. Average of Levels in Binary Tree 计算每一层的平均值
> 对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：
>
> LeetCode 542. 01 Matrix
> LeetCode 994. Rotting Oranges
> 还有一道在真正的图结构中求最短路径的问题：
>
> LeetCode 310. Minimum Height Trees




【LeetCode 752】

可以把它看作迷宫的遍历问题，题目所给的不能到达的状态就是障碍物

换个角度来看，其实就是找**无向图的最短路径**，每个状态四个位能上下拨动，相当于八条边

<img src="../../../../学习/笔记合集/img/image-20210625083647396.png" alt="image-20210625083647396" style="zoom:33%;" />

```c++
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
      string start = "0000";
      unordered_set<string> deadendsSet(deadends.begin(), deadends.end());
      unordered_set<string> visted({start});
      queue<string> q({start});
      int res = 0;
      
      if (deadendsSet.count(start)) return -1;
      if (target == start) return 0;
      
      while (!q.empty()) {
        res++;
        int n = q.size();
        for (int i = 0; i < n; i++) { //每一层序遍历，相当于进行了一次拨动
          string cur = q.front(); q.pop();
          for (int j = 0; j < 4; j++) { //有四个数字可以变动
            for (int k = -1; k <= 1; k+=2) { //数字可以+1或者-1
              string newLock = cur;
            	newLock[j] = (newLock[j] - '0' + k + 10) % 10 +'0';  // 这里+10再取余是为了满足0-1=9 9+1=0
              if (!deadendsSet.count(newLock) && !visited.count(newLock)) q.push(newLock);
              visited.insert(newLock); //这里不用if，因为自动去重
            }
          }
        }
      }
      return -1;
    }
};
```



【LeetCode 773】

这道题的关键在于怎么样处理找到当前结点的边，比较好的解决办法是：先把二维数组压缩为字符串，因为这个图比较小，对于0来说，只有6个可能的位置，因此构造一个dirs数组，对于每个一维数组，表示可以去到的位置。假如0在第0位，那么可以向右到1号，或者向下到3号

更通用的做法是：构造上下左右数组，找到0以后计算0的新位置，然后将他俩进行swap即可，不过这种就不能压缩为字符串来做



【LeetCode815】据说是阿里的暑期实习机试题

还没看这个https://leetcode-cn.com/problems/bus-routes/solution/python-bfs-ba-gong-jiao-kan-zuo-zheng-ti-8w0i/





### 图论

三种经典算法的区别：

- Dijkstra的权重必须为正，其他两个可以为负







#### 单源最短路径 （单个点 - 任意点）

Dijkstra（权重必须为正）

Bellman-Ford 【LeetCode787】



#### 多源最短路径 （任意点 - 任意点）

Floyd



#### 建图

https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247488007&idx=1&sn=9d0dcfdf475168d26a5a4bd6fcd3505d&chksm=fd9cb918caeb300e1c8844583db5c5318a89e60d8d552747ff8c2256910d32acd9013c93058f&token=754098973&lang=zh_CN#rd

https://oi-wiki.org/graph/save/

三种方法：

##### 邻接矩阵

适用于稠密图，边数量 约等于 点的平方

优点：O(1) 查找某条边是否存在

```c++
int[][] w = new int[N][N];

void add(int a, int b, int c) {
  w[a][b] = c;
}
```



##### 邻接表

存各种图都适合，除非有特殊需求（比如快速查询某条边是否存在，且点数比较少）

尤其适合对一个点的出边排序的场合

```c++
vector<vector<int>> adj;
vector<bool> vis;

void dfs(int u) {
  if (vis[u]) return;
  vis[u] = true;
  for (int i = 0; i < adj[u].size(); i++) dfs(adj[u][i]);
}

//如果带权:
unordered_map<int, vector<vector<int>>> m;
```



##### 链式前向星

[参考](https://www.cnblogs.com/wkfvawl/p/9407282.html)

本质上是**用链表实现的邻接表**

适用于边较少的稀疏图，当边约等于点的数量

idx 对边进行编号 1，2，3...

he数组  存储某个节点所对应链表的头结点

e数组    

ne数组

优点：边是带编号的

缺点：不能快速查询某条边，也不能方便地对一个点的出边进行排序

```c++
int cnt = -1;
head[u] = -1;
void add(int u, int v, int w) {
  nxt[++cnt] = head[u];  // 当前边的后继，也就是下一条边的存储下标
  head[u] = cnt;       // head[u]表示以u为起点的第一条边，实际上这里第一条边存储的位置在以u为起点所有边最后被输入的那个编号，因为当一个结点有多个出度的时候，以u为结点的边会不断被更新
  to[cnt] = v;           // 当前边的终点
}

// 遍历 u 的出边
for (int i = head[u]; ~i; i = nxt[i]) {  // ~i 表示 i != -1
  int v = to[i];
}
```

具体过程：nxt[cnt]不断更新为上一个被记录过的head[u]，也就是说，后续遍历边的过程和读入边的过程是相反的





##### 直接存边

比如以Edge类的形式进行存储





#### 有限制的最短路问题 - Bellman Ford

限制路径不超过k条边的问题（注：限制不超过k个点等价于不超过k+1条边）

这类问题SPFA不能直接解决







#### 拓扑

前提：有向无环图DAG

在序列中，有向边起点一定先于终点出现

应用：在有向图中判断是否有环，如果有环，则无法提取出拓扑序列

拓扑排序本质是先找到入度为0的结点，以及仅由入度为0结点指向的结点

<img src="../../../../学习/笔记合集/img/image-20210820092524469.png" alt="image-20210820092524469" style="zoom:33%;" />

在进行BFS前，需要存储两个数组：

- 每个结点的入度
- 图的邻接表

```c++
	queue<int> q;
void topologicSort() {
  // 拓扑排序
  queue<int> q;

  // 首先将入度为 0 的点存入队列
  for(int i = 0; i < n; i++) {
    if(!Indeg[i]) {
      q.push(i);
    }
  }
  while(!q.empty()) {
    // 每次弹出队头元素
    int cur = q.front();
    q.pop();

    for(int x : new_graph[cur]) {
      // 将以其为起点的有向边删除，更新终点入度
      Indeg[x]--;
      if(!Indeg[x]) q.push(x); //如果入度为0，那么可以加入队列
    }
  }
  
  // 最终入度（原图中出度）为 0 的所有点均为安全点
  vector<int> ret;
  for(int i = 0; i < n; i++) {
    if(!Indeg[i]) ret.push_back(i);
  }
  return ret;
}

```



【LeetCode 802】

这道题是要找到出度为0的结点，以及仅由出度为0结点指向的结点，刚好与拓扑的目标相反，因此把这个有向图反转，也就是有向边的起点终点互换即可。

【LeetCode 207】

【LeetCode 210】

【LeetCode 329】

【LeetCode 1203】



#### 三色标记法

【LeetCode 802】

三种颜色：

白 - 0 未访问

灰 - 1 处于递归中，或者处于环中

黑- 2 搜索完毕，是安全结点

```c++
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> res, color(n);
        // 0 - while 1 - gray 2 - black 
        for (int i = 0; i < n; i++) {
            if (helper(graph, i, color)) res.push_back(i);
        }
        return res;
    }

    bool helper(vector<vector<int>>& graph, int i, vector<int>& color) {
        if (color[i] == 2) return true;
        if (color[i] == 1) return false;
        color[i] = 1;
        for (int next : graph[i]) {
            if (!helper(graph, next, color)) return false;
        }
        color[i] = 2;
        return true;
    }

};
```



#### 旅行商问题

一般形式：求解访问每一座城市，最后回到起始城市的最短回路

本质：在一个带权无向图中，找一个权值最小的哈密尔顿回路











### 回溯 - 适合用于搜索一个问题<u>所有的解</u>

回溯在发现某个方式不可能是结果的时候，退回上一步尝试其他可能

[LeetCode讲解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

回溯和DFS的思想类似，不撞南墙不回头

区别是：DFS是遍历树或者图，甚至森林的方法，而回溯是遍历问题空间来找解决方案的办法，比起DFS更为通用

> DFS，递归，栈 都是后进先出

回溯 vs dp：

- dp只要求求出最优解，但不关心最优解对应的具体解（比如说dp[i] = max(dp[i-1], dp[i-2]) 只知道最优解是dp[i]，但不要求过程）；适合用于评估一个方案的效果
- 回溯可以搜索到所有的方案，本质是一个遍历算法
- dp需要存储子问题的解，回溯不需要
- 回溯可以用所有穷举法可以解决的问题，dp只用于最优子结构的问题

回溯无敌模版：

```c++
res = []
path = []

def backtrack(未探索区域, res, path):
    if 未探索区域满足结束条件:
        res.add(path) # 深度拷贝
        return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop() //我们从始至终只用了一个变量 path，所以当对 path 增加一个选择并 backtrack 之后，需要清除当前的选														择，防止影响其他路径的搜索

```

相关题目：【LeetCode131】

本题需要我们把字符串分成一系列的回文子串，按照模板，我们的思路应该是这样的：

未探索区域：剩余的未搜索的字符串 s；
结束条件：s 为空；
未探索区域当前可能的选择：每次选择可以选取 s 的 1 ~ length 个字符，cur = s[0...i]cur=s[0...i]；
当前选择符合要求：cur 是回文字符串 isPalindrome(cur)；
新的未探索区域：s 去除掉 cur 的剩余字符串，s[i + 1...N]s[i+1...N]。

【LeetCode78，LeetCode90】



【剑指Offer 38】

这道题目是要获得字符串中字符的全排列

按照正常的思考逻辑，假如没有重复字符，那就是n * (n-1)* .... 1种可能，直接BFS即可

但现在有重复字符，需要进行回溯



【LeetCode526】

递归函数的关键是：确定终止条件，for循环变量的初始位置

```c++
class Solution {
public:
    int countArrangement(int n) {
      vector<int> visited(n+1, 0); //排列不能有重复，所以设置一个visited
      int pos = 1, res = 0; //pos表示已经生成序列中数字个数
      helper()
      return res;
    }
  void helper(int n, int pos, int& res, vector<int.& visited) {
    if (pos > N) {
      res++;
      return;
    }
    for (int i = 1; i <= N; i++) { //这里从1开始遍历，因为需要序列包括所有的数字
      if (visited[i] != 0 && (i % pos == 0 || pos % i == 0)) {
        visited[i] = 1;
        helper(n, pos+1, res, visited);
        visited[i] = 0;
      }
    }
  }
};
```

由于题目给出N最大是15，这道题还可以用DP的状态压缩来做



这道题的本质是求全排列，然后从全排列中过滤出符合要求的排列，**全排列的经典做法**就是**交换数组中任意两个数字**

```c++
class Solution {
public:
    int countArrangement(int N) {
        vector<int> nums(N);
        for (int i = 0; i < N; ++i) nums[i] = i + 1;
        return helper(N, nums);
    }
    int helper(int n, vector<int>& nums) {
        if (n <= 0) return 1;
        int res = 0;
        for (int i = 0; i < n; ++i) {
            if (n % nums[i] == 0 || nums[i] % n == 0) {
                swap(nums[i], nums[n - 1]);
                res += helper(n - 1, nums);
                swap(nums[i], nums[n - 1]);
            }
        }
        return res;
    }
};
```





### 买股票问题：

只允许一次交易：遍历更新最小值，并取最大收益即可

不限制交易次数：遍历，只要能产生收益就加进来，返回累加和（一天内可以买或者卖）

限制交易次数：

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<int> sell(k+1,0);
        vector<int> buy(k+1,INT_MIN);
        for(int price : prices)
        {
            for(int i = 1;i <= k; i++) {
                buy[i] = max(buy[i],sell[i-1] - price);
                sell[i] = max(sell[i],buy[i] + price);
            }
        }
        return sell[k];
    }
};
```

注：内层循环以k=2比较好理解：

b1 = max(b1, -p);
s1 = max(s1, b1 + p);
b2 = max(b2, s1 - p);
s2 = max(s2, b2 + p);

这里的s1相当于sell[i-1]，b2相当于buy[i]，用自然语言解释就是(b2)是取b2和(前一次交易卖的利润-当前price)的最大值，s2就是取sell2和上一次买的股票加上以当前价格卖出的最大值

参考：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1).

限制最大交易次数：

直接令最大交易次数`k = min(k, n/2)`即可 



-

### 滑动窗口问题

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

注意：内循环和外循环都是：先更新sum/res，再更新指针

> 以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

ps：记录一下，https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/，没有看懂

![image-20210205194837544](../../../../学习/笔记合集/img/image-20210205194837544.png)

我的一点心得：

曾经把几道题误判为用滑动窗口来做，但最后发现都不可以用。区别好像在于滑动窗口移动窗口的过程中一般不会让l右移到和r重合的，而这几道题目似乎都有可能有这种情况。

比如LeetCode525，LeetCode523

例：LeetCode424

> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
>
> 注意：字符串长度 和 k 不会超过 104。
>
> ```
> 输入：s = "ABAB", k = 2
> 输出：4
> 解释：用两个'A'替换为两个'B',反之亦然。
> ```

```c++
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2) {
        return p1.second < p2.second;
    }

    int characterReplacement(string s, int k) {
        int l = 0, r = 0, n = s.size();
        int res = 0, maxCnt = 0;
        int counts[26];
        memset(counts, 0, sizeof(counts));
        while (r < n) {
            counts[s[r] - 'A']++;
            // maxCnt = max_element(m.begin(), m.end(), cmp)->second;
            maxCnt = max(maxCnt, counts[s[r] - 'A']);
            while (r - l + 1 - maxCnt > k) {
                counts[s[l] - 'A']--;
                l++;
            }
            res = max(res, r - l + 1);
            r++;
        }
        return res;
    }
};
```

例：【LeetCode 1004】

关键是做题意的转换

**最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度**  -> 找一个包含K个0的最长子数组





【LeetCode 930】

这道题有一点变化在于，找到满足题意的窗口后，还需要加上窗口左边连续0的情况。

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        int res = 0, n = nums.size();
        int l = 0, r = 0;

        int cur = 0;
        while (r < n) {
            cur += nums[r];
            while (cur > goal && l < r) cur -= nums[l++]; //注意这里加了l < r的限制条件
            if (cur == goal) {
                res++;
                for (int j = l; j < r && nums[j] == 0; j++) res++;
            }
            r++;
        }
    }
};
```



【LeetCode 1838】

这道题我的思路是模拟 + 贪心

第一层循环作为右边界，然后能用最小增幅对结果产生最大贡献的就是从当前右边界往回找，直到不满足

题解的思路是用滑动窗口，没想到的一点是更新当前用掉的k，采用`(nums[r] - nums[r-1]) * (r - l)`

解释有点类似于前缀和，相当于在nums[r-1]的基础上，对窗口内的每个元素加这个差值

```c++
class Solution {
public:
    int maxFrequency(vector<int>& nums, int k) {
        int res = 1, n = nums.size();
        sort(nums.begin(), nums.end());
        int l = 0, r = 1;
        long long curK = 0;
        while (r < n) {
            curK += (long long) (r - l) * (nums[r] - nums[r-1]);
            while (curK > k) {
                curK -= (nums[r] - nums[l]);
                l++;
            }
            res = max(res, r - l + 1);
            r++;
        }
        return res;
    }
};
```





滑动窗口题目简单版本：

某些简单题目，比如最大连续1的个数，这种不需要用双指针，将l记录非0数字，r向右移动即可



一些变式：

【LeetCode 220】

滑动窗口来保存所有下标满足条件的元素

比较特殊的点是需要用一个有序的数据结构来保存，可以选set、multiset、map

由于有有序性，因此可以用lower_bound查看是否存在这样的元素，只要存在，那肯定符合题意

```c++
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
      int n = nums.size();
      int l = 0, r = 0;
      map<long long, int> m;
      while (r < n) {
        if (r - l > k) {
          m.erase(nums[l++]);
        }
        auto it = m.lower_bound((long long)nums[r] - t);
        if (it != m.end() && abs(it->first - nums[r]) <= t) return true;
        m[nums[r]] = r;
        r++;
      }
      return false;
    }
};
```





### 盛雨水问题

LeetCode 11 

`res = max(res, 短板 * 板子之间距离)`

需要注意的就是移动左指针，还是右指针

因为板子之间距离必然减小，所以只有移动短板才可能变大，移动长板的话，那结果肯定小于等于原来的res

https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/fu-xue-ming-zhu-mian-xiang-lie-de-ji-sua-6uqr/





【LeetCode  面试题17.21 直方图的水量】

视角应该放在每个列上，每个列能盛的雨水取决于该列左边最高列和右边最高列的最小值

问题转化为，给定一个数组，如何求任何位置左边最大值和右边最大值

基础解法：

```c++
class Solution {
public:
    int trap(vector<int>& height) {
      int n = height.size();
      int lMax = 0, rMax = 0;
      int res = 0;
      for (int i = 1; i < n - 1; i++) { //这里需要跳过第一个和最后一个，因为它们不能接雨水，两边是漏的
        int lMax = *max_element(height.begin(), height.begin() + i);
        int rMax = *max_element(height.begin() + i, height.end());
        int cur = min(lMax, rMax) - height[i];
        if (cur > 0) res += cur; //如果大于0，表示能蓄水
      }
      return res;
    }
};
```



由于进行了很多次提前计算，所以可以提前计算好每个点的左边最大和右边最大

```c++
class Solution {
public:
    int trap(vector<int>& height) {
      int n = height.size();
      vector<int> lMax(n - 2), rMax(n - 2);
      for (int i = 1; i < n - 1; i++) {
        lMax[i] = max(lMax[i-1], height[i-1]);
      }
      for (int i = n - 2; i > 0; i--) {
        rMax[i] = max(rMax[i+1], height[i+1]);
      }
      int res = 0;
      for (int i = 1; i < n - 1; i++) { //这里需要跳过第一个和最后一个，因为它们不能接雨水，两边是漏的
        int cur = min(lMax[i], rMax[i]) - height[i];
        if (cur > 0) res += cur; //如果大于0，表示能蓄水
      }
      return res;
    }
};
```



双指针法：

双指针法是对预处理计算最大值的进一步优化

整体思路是两头同时开始计算左右边分别能接多少的水

<img src="../../../../学习/笔记合集/img/image-20210708150601915.png" alt="image-20210708150601915" style="zoom:33%;" />

```c++
class Solution {
public:
    int trap(vector<int>& height) {
      int n = height.size();
      int res = 0;
      int l = 0, r = n - 1;
      int lMax = 0, rMax = 0;
      while (l < r) {
        lMax = max(height[l], lMax);
        rMax = max(height[r], rMax);
        if (height[l] < height[r]) {
          res += lMax - height[l++];
        } else {
          res += rMax - height[r--];
        }
      }
      return res;
    }
};
```





单调栈法：[参考](https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/zhi-fang-tu-de-shui-liang-by-leetcode-so-7rla/)

为什么想到单调栈？

对于i位置，要求某侧最近比它大的值，因此想到了单调栈

对于x位置被弹出，引起弹出的元素是右边比x大的值，x弹出后的栈顶元素是左边比x大的值

（ps：似乎在单调栈中没有特别关注左右边界的情况）



总体来看，单调栈就是累加一个一个能形成水坑的面积，即中间低，两边高这个模型。（有点类似人类直接计算结果的方法 0



关注三个元素：

栈顶元素是x位置，i是引起x位置弹出的元素，也就是右边第一个比它大的元素（相当于右边的一个高板），把x位置弹出后，栈顶元素是左边比x大的第一个元素（不一定是相邻元素）

```c++
class Solution {
public:
    int trap(vector<int>& height) {
      int n = height.size();
      int res = 0;
      stack<int> st; //栈中存储下标，因为需要计算长 * 宽
      for (int i = 0; i < n; i++) {
        while (!st.empty() && height[i] > height[st.top()]) {
          int pre = st.top(); st.pop();
          if (st.empty()) break;
          int left = st.top();
          int curHeight = min(height[left], height[i]) - pre;
          res += (i - left - 1) * curHeight;
        }
        st.push(i);
      }
    }
};
```









### 双指针问题

【LeetCode 26 80】

此类问题的关键是明确指针的含义。

以80为例，slow表示是即将放置元素的位置，fast是向后遍历的元素。

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 2, n = nums.size();
        if (n <= 2) return n;
        for (int fast = 2; fast < n; fast++) {
            if (nums[slow-2] != nums[fast]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
};
```

【LeetCode 881】

这道题如果$$O(N^2)$$会超时

所以必须用双指针，其实也是贪心的算法，让重的一边先占一条船，然后把轻的与重的进行组合

```c++
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        int res = 0, n = people.size();
        sort(people.begin(), people.end(), greater<int>());
        int lo = 0, hi = n - 1;
        while (lo <= hi) { //注意这里的while条件可以取等，因为当二者相遇，表示还有一个人没上船，这里由于题目说了一条船最多两个人，所以新增一条船即可
            if (people[lo] + people[hi] <= limit) {
                lo++; hi--;
                res++;
            } else {
                res++;
                lo++;
            }
        }
        return res;
    }
};
```





### 扫描线问题

一道特殊的扫描线问题【LeetCode 218】

还得再多理解

```c++
class Solution {
public:
    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {
        vector<vector<int>> res, h;
        multiset<int> s;
        for (auto b :  buildings) {
            h.push_back({b[0], -b[2]});  //左边边界的高度存为负数
            h.push_back({b[1], b[2]});
        }
        sort(h.begin(), h.end());  //根据坐标进行排序
        int pre = 0, cur = 0;
        s.insert(0);  //标准解释是，这样的话在某个没有和其他建筑重叠的右边界上，就可以将封闭点存入结果 res 中
        for (auto a : h) {
            if (a[1] < 0) s.insert(-a[1]);
            else s.erase(s.find(a[1]));  //说明是右边界走完了
            cur = *s.rbegin(); //取出最后一个元素，也就是最高高度
            if (cur != pre) {
                res.push_back({a[0], cur});
                pre = cur;
            }
        }
        return res;
    }
};
```





### 计数类模拟题

【LeetCode233，剑指Offer43】

参考https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/

这道题的做法是：计算1～n个位、十位一直到最高位每一位1出现的次数，并且累加

把一个数分为三部分，比如2324，23作为高位，4作为低位，2是cur

根据当前位cur值的不同：分为三种可能性：

- cur = 0

<img src="../../../../学习/笔记合集/img/image-20210818145549642.png" alt="image-20210818145549642" style="zoom:33%;" />

- cur = 1

<img src="../../../../学习/笔记合集/img/image-20210818145606291.png" alt="image-20210818145606291" style="zoom:33%;" />

- cur > 1

<img src="../../../../学习/笔记合集/img/image-20210818145623162.png" alt="image-20210818145623162" style="zoom:33%;" />

```c++
class Solution {
public:
    int countDigitOne(int n) {
      int res = 0, digit = 1; //从个位开始计算
      int high = n / 10, low = 0, cur = n % 10;
      while (high != 0 || cur != 0) {
        if (cur == 0) res += high * digit;
        else if (cur == 1) res += high * digit + low + 1;
        else res += (high + 1) * digit;
        
        low += cur * digit;
        cur = high % 10;
        high /= 10;
        digit *= 10;
      }
      return res;
    }
};
```





### 位运算

&和&&区别：

&&和||的两边只能是bool类型

&和|既可以逻辑运算，也可以位运算；也就是说对bool类型直接逻辑运算，对int整型做按位与



【重要】

- 获得二进制数中的1的个数

  ```c++
  int n = __builtin_popcount(num);
  ```

- 判断mask第i位是否为0的方法：

  ```c++
  if (mask & (1 << i))
  ```

- 判断mask最低位是否为0的方法：

  ```c++
  if (mask & 1 == 0)
  ```

- 让mask第i位赋值为1的方法：

  ```c++
  mask |= (1 << i)
  ```

- 让mask第i位赋值为0的方法：使用异或

  ```c++
  mask ^ (1 << i)
  ```

  

- 判断数字n是否为2的幂：【LeetCode231】

  特点：2的幂

  - 去除最低位1的方法：

    - n & (n-1)，假如结果为0，那么正整数n为2的幂

      证明： n是100000 n-1就是011111，与运算后所有的位都变为0

  - 获取最低位的1:

    - n & (-n)，如果结果为n，那么正整数n为2的幂





相关题目：

【LeetCode190】

【LeetCode 78】

这个题目也就是相当于求出 0 ～ 111111的全排列

左移几位就是往后面补几个0

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
      vector<vector<int>> res;
      vector<int> vec;
      int n = nums.size();
      
      for (int mask = 0; mask < (1 << n); mask++) { // mask < 1000
        vec.clear();
        for (int i = 0; i < n; i++) {
          // 判断第i位是否为1
          if (mask & (1 << i)) vec.push_back(nums[i]); // mask=111 i=2 -> 111 & 100
        }
        res.push_back(vec);
      }
      
      return res;
    }
};
```



【LeetCode191】

计算某个数字的二进制表示有多少个1

- 普通方法：

```c++
int num = 2, cnt = 0;
while (num > 0) { //num等于0已经要结束了
  cnt += num & 1;  //这个是判断最低位是否为1
  num >>= 1;
}
```

- 特殊方法：

假如要求一连串的，比如0到n的数字各有多少；有两种方法：

【LeetCode 338】

```c++
int num = 10;
vector<int> ans(num+1);
for (int i = 0; i <= num; i++) {
  if (i % 2 == 0) ans[i] = ans[i/2]; //比如2和4，4只是2在低位补0，总1不变
  else ans[i] = ans[i-1] + 1; //奇数的话等于离它最近的偶数+1
}
```

另一种特殊思路

> ```
> i    binary '1'  i&(i-1)
> 0    0000    0
> -----------------------
> 1    0001    1    0000
> -----------------------
> 2    0010    1    0000
> 3    0011    2    0010
> -----------------------
> 4    0100    1    0000
> 5    0101    2    0100
> 6    0110    2    0100
> 7    0111    3    0110
> -----------------------
> 8    1000    1    0000
> 9    1001    2    1000
> 10   1010    2    1000
> 11   1011    3    1010
> 12   1100    2    1000
> 13   1101    3    1100
> 14   1110    3    1100
> 15   1111    4    1110
> ```

二进制中1的个数也就是 i & (i-1)中的数+1，这样就形成了递推式

```c++
res[i] = res[i & (i-1) + 1]
```

TODO 

【LeetCode 137】



【LeetCode477】

本题目的要求是计算所有数字两两组合的汉明距离，暴力法会TL。

正确的做法：统计在第i位为1的有tmp个数字，那么第i位为0的有n-tmp个，因此在这一位产生的汉明距离就是 tmp * (n - tmp)个

解释就是会在这tmp与(n-tmp)做汉明距离的时候会产生不同

【LeetCode 421】

核心是从高位到低位一位位的进行遍历，判断每一位是否可能为1 

具体来讲，res是从10000一直遍历，判断11000是否可能，11100是否可能等等，以此类推

```c++
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size(), res = 0, mask = 0;
        for (int i = 30; i >= 0; i--) {
           //不断取出前缀，就是从第i位到最低位。最高位到i位是已经确定的部分
            mask |= (1 << i); 
            unordered_set<int> s;
            for (int num : nums) {
                s.insert(num & mask);
            }
         
          	// 当前res和第i位结果取或运算，就是目标结果t，比如当前res是10000，t就是11000，然后依次遍历。 因为题目要求是两个前缀的结果，利用异或的性质，如果前缀和目标的结果仍然还在s里，说明此位为1能取到
            int t = res | (1 << i);
            for (int prefix : s) {
                if (s.count(t ^ prefix)) {
                    res = t;
                    break;
                }
            }
        }
        return res;
    }
};
```



【LeetCode 1442】

本道题的核心还是运用了异或的特性 a ^ b = c 那么 c ^ a = b

通过转化，可以将题目要求转化为 $$xorSum[i] = xorSum[k+1]$$

<u>这里需要注意的是异或前缀和数组，题解是构建了一个长度为n+1的数组，下标从0开始</u>（如果取长度为n的话，要求的就$$xorSum[i-1] = xorSum[k]$$ ，这样不太好确定二重遍历的下标）

```c++
class Solution {
public:
    int countTriplets(vector<int>& arr) {
        int n = arr.size(), res = 0;
        vector<int> xorSum(n+1);
        xorSum[0] = 0;
        for (int i = 0; i < n; i++) {
            xorSum[i+1] = xorSum[i] ^ arr[i];
        }

        // s[j]^ s[i] = s[k+1] ^ s[j]
        for (int i = 0; i < n; i++) {
            for (int k = i + 1; k < n; k++) {
                if (xorSum[i] == xorSum[k+1]) {
                    // i+1 到 k的所有j都满足题意
                    res += k - i;
                }
            }
        }
        return res;
    }
};
```

优化思路：

[参考](https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/xing-cheng-liang-ge-yi-huo-xiang-deng-sh-jud0/)

因为最后要求的是(k-i1) + (k-i2) ..... (k-im) = mk - (i1 + i2 .... im)

所以把i 的出现次数m和i的和存下来即可

```c++
class Solution {
public:
    int countTriplets(vector<int> &arr) {
        int n = arr.size();
        vector<int> s(n + 1);
        for (int i = 0; i < n; ++i) {
            s[i + 1] = s[i] ^ arr[i];
        }
        unordered_map<int, int> cnt, total; //cnt表示出现次数，total表示下标和
        int ans = 0;
        for (int k = 0; k < n; ++k) {
            if (cnt.count(s[k + 1])) {
                ans += cnt[s[k + 1]] * k - total[s[k + 1]];
            }
            ++cnt[s[k]];
            total[s[k]] += k;
        }
        return ans;
    }
};

```

【LeetCode 526】

因为是求解的个数，这道题也可以用标准的回溯模版做

下面是位运算方法：

mask中的1表示有哪位被选中，比如100110，表示2，3，6被选中，并且在序列前三位，但全排列方式未知，需要经过筛选

然后分别判断2，3，6是否能放在最高位第三位，然后再加上另外两个的全排列（也就是先从被选取的数字中找到能放到最高位 num 的数字，然后将剩余 num-1 个数字的完美排列方式累加到f[mask]中）

比如第三位可以是6，然后f[100110] += f[000110]

这里有个容易想错的地方：这里题目中说的第i个位置，是最后放在序列中的位置，而不是在mask的位置，mask只是起到表示选了哪些数字的目的

```c++
class Solution {
public:
    int countArrangement(int n) {
      vector<int> dp(1<<n); //表示符合要求的某个表示的排列个数，比如110表示123中2和3被选中 
      dp[0] = 1;
      for (int mask = 0; mask < (1 << n); mask++) {
        int num = __builtin_popcount(mask); //1的个数，表示选了几个数
        for (int i = 0; i < n; i++) { //从1位遍历到第n-1位，看有哪个数字能做当前mask的最高位，（这个是对mask的遍历，由于题目中说是数组的第i个数字，也就是[1,N]，因此是i+1位
          if (mask & (1 << i) && (num % (i+1) == 0 || (i+1) % num == 0)) { //前面的条件判断mask第i位是否为1，也就是数字i+1是否被选中，然后再判断i+1能否放在位置num上
            dp[mask] += dp[mask ^ (1<<i)] //第i位设置为1
          }
        }
      }
      return dp[(1 << n) - 1]
    }
};
```

附上一个更为详细的解释：

```c++
// 用 mask 的二进制表示选取状态，n 个数字用 n 位表示，第 i 位为 1 代表数字 i+1 已被选取（i从0开始），n 中 1 的个数 m 代表前 m 位已放置
   // 例如：二进制 100110 共三个1，代表排列的前三位已放置数字，三个1分别在二进制第 1、2、5位置上(从右侧开始，从0开始计数）, 所以 2、3、6三个数字被选取，综合起来就是表示：2 3 6 这三个数字被放到了排列的前三位，三个数字完美排列方式未知，通过枚举 mask 进行计算

     class Solution {
         public int countArrangement(int n) {
             // 用来存储中间结果，f[6] = f[000110] = 数字2、3在前两位时的完美排列数量
             int[] f = new int[1 << n];
             f[0] = 1;
             // 通过 mask 进行枚举，最终目的是为了得到二进制 mask = (11..11)n 时，总的完美排列数 
             for (int mask = 1; mask < (1 << n); mask++) {
                 int num = Integer.bitCount(mask);
                 // 遍历 mask 的每一位，仍以 mask = 100110 为例，此 mask 代表 2 3 6三个数字在排列的前三位
                 // 求三个数字 2 3 6 的完美排列方式，则先确定2 3 6哪些数字能放到第三位，然后累加另外两个数字的完美排列数量来获得
                 // 2 3 6，第三位可以为 6，则 f[100110] += f[000110] (2、3在前两位时的完美排列数量)
                 // 2 3 6，第三位可以为 3，则 f[100110] += f[100010] (2、6在前两位时的完美排列数量)
                 for (int i = 0; i < n; i++) {
                     // mask & (1<<i) 用来判断 mask 第 i 位是否为 1，如果为 1，说明第 i+1 个数字被选取
                     // ((num % (i + 1)) == 0 || (i + 1) % num == 0) 判断被选取的数字 i+1 能否放到位置 num 上，
                     // 即：先从被选取的数字中找到能放到最高位 num 的数字，然后将剩余 num-1 个数字的完美排列方式累加到f[mask]中
                     if ((mask & (1 << i)) != 0 && ((num % (i + 1)) == 0 || (i + 1) % num == 0)) {
                         // mask ^ (1 << i) 将 mask 第 i 位设置为 0
                         f[mask] += f[mask ^ (1 << i)];
                     }
                 }
             }
             return f[(1 << n) - 1];
         }
     }
```

【LeetCode 600】

dp[k]表示长度为k的二进制数字没有连续1的个数，以k=5为例，包含的数字范围是00000-11111，其实就是看00000-10111，因为11000-11111前面已经有连续1了。然后符合条件的范围又可以被分为00000-01111和 10000 - 10111，正好对应dp[4]和dp[3]。

因此符合斐波那契数列，也就是dp[k] = dp[k-1] + dp[k-2]

```c++
class Solution {
public:
    const int N = 31;
    int findIntegers(int n) {
        int res = 0, pre = 0;
        vector<int> dp(N + 1);
        dp[0] = 1; dp[1] = 2;
        for (int i = 2; i < N; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        int k = N;
        while (k--) {
            if (n & (1 << k)) { //当前位是1
                res += dp[k]; //因为如果当前位如果变成0，后面k位就相当于dp[k]
                if (pre) return res; //有连续1，直接返回
                pre = 1;
            } else pre = 0;
        }
        return ++res; //最后要加上数字本身，这个暂时还不懂
    }
};
```

比较特殊的题目：

【LeetCode1239】



### 前缀和问题

应用场景：除一般的需要计算子数组和的情况外，一般子数组问题都可以思考是否能用前缀和

区间类问题

##### 一维前缀和

前缀和数组长度一般为n+1，第0号元素为0，为的是求i元素前所有元素的和这种情况

```c++
vector<int> preSum(n+1);
for (int i = 1; i <= n; i++) {
  preSum[i] = preSum[i-1] + nums[i-1];
}
```



##### 二维前缀和



理解：

<img src="../../../../学习/笔记合集/img/image-20210302102731472.png" alt="image-20210302102731472" style="zoom:33%;" />

> S(O,D) = S(O,C) + S(O,B)-S(O,A)

```c++
vector<vector<int>> preSum;
preSum.resize(row+1, vector<int>(column+1, 0)); //这里设置比原有的矩阵多一行一列，是为了让(0,0)也可求

//预处理求前缀和
for (int i = 0; i < row; i++) {
  for (int j = 0; j < column; j++) {
    preSum[i+1][j+1] = preSum[i][j+1] + preSum[i+1][j] - preSum[i][j] + matrix[i][j];
  }
}
```

<img src="../../../../学习/笔记合集/img/image-20210302103755376.png" alt="image-20210302103755376" style="zoom:33%;" />

> S(A,D) = S(O,D) - S(O,E) - S(O,F) + S(O,G)

```c++
// 求(row1, column1)到(row2, column2)的和
return preSum[r2+1][c2+1] - preSum[r2+1][c1] - preSum[r1][c2+1] + preSum[r1][c1]
```

补充：这里因为用了辅助行，(r2,c2)对应的是(r2+1,c2+1)



下面的两道题比较类似，都利用了前缀和，并且借助哈希表，找出当前前缀和与之前前缀和之间的关系，最后求出结果。

然后具体实现上有一个比较重要的**易错点**，那就是哈希表需要留出第一个位置，作为一个哨兵节点，它的主要作用是在求后面的前缀和的时候，可能需要利用到该位置以前的全部元素，因此多加入一个元素就可以实现这个效果。

【LeetCode 525】

```c++
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int res = 0, n = nums.size(), sum = 0;
        unordered_map<int, int> m({{0,-1}}); // key是01序列和，value是这个序列的结束下标
        for (int i = 0; i < n; i++) {
            sum += (nums[i] == 0) ? -1 : 1; //等价于sum += (nums[i] << 1) -1;
            if (m.find(sum) != m.end()) res = max(res, i - m[sum]); //前缀和如果相同，说明之间的子数组0和1数量相同
            else m[sum] = i; //只有找不到对应的sum才进行更新，因为要找最大值，所以map里的value越小越好
        }
        return res;
    }
};
```



【LeetCode 930】不错的题目

需要关注for循环中的语句顺序，比如`m[curSum]++`不能先执行，因为它不是算作当前的前缀和

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
      int res = 0, n = nums.size();
      int curSum = 0;
      unordered_map<int, int> m{{0,1}}; //哈希表留出第一个位置，为了计算从头到cur的前缀和
      for (int num : nums) {
        curSum += num;
        res += m[curSum - goal]; //curSum - x = goal 所以要找到符合条件的前面的前缀和
        m[curSum]++;
      }
      return res;
    }
};
```





【LeetCode 523】

补充：同余定理，假如 $$\frac{sum[j]}{k} - \frac{sum[i-1]}{k} = n$$，因为如果让两个商相减为整数，那么$$sum[j]$$和$$sum[i-1]$$取余相同

```c++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> preSum(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i-1] + nums[i-1];
        }

        // 前缀和满足余数相同.   sum[i] - sum[j] = n * k
        unordered_set<int> st;
        for (int i = 2; i <= n; i++) {
            int cur = preSum[i-2] % k; //通过i-2来保证取到的子数组至少两个元素
            st.insert(cur);
            if (st.find(preSum[i] % k) != st.end()) return true;
        }
        return false;
    }
};
```



### 差分数组法

差分是求前缀和的逆向过程

以[1,2,2,4]为例，差分数组为[1,1,0,2]，即差分数组第i位表示nums[i] - nums[i-1]

而对差分数组计算前缀和就是原数组

当[l,r]有增量inc时，等价于d[l] + inc 并且 d[r+1] - inc(当r!=n，如果二者相等，那么不需要变化)

【LeetCode 1109】

```c++
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<int> res(n);
        for (int i = 0; i < bookings.size(); i++) {
            vector<int> b = bookings[i];
            res[b[0] - 1] += b[2]; //因为编号是1到n，所以要减1
            if (b[1] < n) res[b[1]] -= b[2];
        }
        for (int i = 1; i < n; i++) {
            res[i] += res[i-1]; //每一站人数等于前一站变化人数加上当前变化人数
        }
        return res;
    }
};
```



【LeetCode 995】还没做过，先归类



【LeetCode 1893】

朴素的方法就是遍历区间范围，把区间能包含的整数都存起来，然后再遍历目标区间，看是否有元素不在set里面



查分数组法 + 前缀：

`diff[i]`表示区间覆盖整数i的数量与覆盖整数i-1的数量差

当遍历到区间range[l, r] ，l相对于l-1区间数量+1，r相对于r+1区间数量+1

前缀和表示[1, i]的变化量之和，如果大于0表示当前有区间覆盖，如果小于0表示没有被覆盖

```c++
class Solution {
public:
    bool isCovered(vector<vector<int>>& ranges, int left, int right) {
        vector<int> diff(52, 0);   // 差分数组
        for (auto&& range: ranges) {
            ++diff[range[0]];
            --diff[range[1]+1];
        }
        // 前缀和
        int curr = 0;
        for (int i = 1; i <= 50; ++i) {
            curr += diff[i];
            if (i >= left && i <= right && curr <= 0) {
                return false;
            }
        }
        return true;
    }
};
```

拓展：https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/

持久化树状数组/主席树





### 区间和问题

- 数组不变，求区间和 
  - **前缀和**，树状数组，线段树
- 单点修改，求区间和
  - **树状数组**，线段树
- 区间修改，单点查询
  - **差分**，线段树
- 区间修改，求区间和
  - **线段树**，树状数组（看修改区间的数据范围）

只有到第四种，才不得不用线段树

求区间和思考优先级：

1. 简单求区间和，用前缀和
2. 多次把一个区间变成同一个数，用线段树
3. 其他情况用树状数组



##### 树状数组模版：

【LeetCode 307】

```c++
vector<int> tree;
int lowbit(int x) {
  return x & -x;
}
//查询前缀和
int query(int x) {
  int ans = 0;
  for (int i = x; i > 0; i -= lowbit(i)) ans += tree[i];
  return ans;
}
//在树状数组位置x上增加值u
void add(int x, int u) {
  for (int i = x; i <= n; i += lowbit(i)) tree[i] += u;
}
//初始化树状数组，默认数组从1开始
for (int i = 0; i < n; i++) add(i + 1, nums[i]);

void update(int i, int val) {
  // 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]
  add(i + 1, val - nums[i]); 
  nums[i] = val;
}
    
int sumRange(int l, int r) {
  return query(r + 1) - query(l);
}

```



### 单调栈问题 - 处理前后<u>元素之间的大小关系</u>

```c++
insert x;
while !st.empty() && st.top() < x :
	st.pop();
st.push(x);
```

s元素出栈的时机：不再单调

单调栈的性质：

- 单调栈中的元素具有单调性
- 递增（减）栈可以找到元素左右两侧第一个比自己小（大）的元素



找i位置某侧比它大的值，用递减栈；找i位置某侧比它小的值，用递增栈



【LeetCode 503】

题目的要求是找到数组中每个数字的下一个最大的元素；暴搜的话，如果处理类似[6,5,4,3,9]这种数组的时候，数组中递减的部分的下一个最大的元素相同，可以一并返回

```c++
vector<int> nextGreaterElements(vector<int>& nums) {
  int n = nums.size();
  vector<int> res(n, -1);
  stack<int> st;
  for (int i = 0; i < n * 2; i++) {
    int num = nums[i % n];
    while (!st.empty() && nums[st.top()] < num) {
      res[i % n] = num;
      st.pop();
    }
  }
  return res;
}
```

【LeetCode 456】

132模式（贪心的解读：1尽可能小，2尽可能大）

暴力解法 ：

$$O(N^2)$$ 有点贪心的思想，遍历数组时候，以132模式中的3为关注点，左边维护一个3左边数组的最小值，右边通过暴力搜索一个比3小，比1大的一个数字

单调栈：

问题的突破口是132模式中的2，也就是第三个数字，因为第一个数字是找最小，中间是最大，第三个数字的限制比较多。

其实2就是要**<u>找到比3小的最大元素</u>**，因此建立一个单调栈比较合适

因此从后往前遍历，建立一个递减栈，并且栈中的数字都是大于第三个数字的，一直从后往前遍历，如果碰到破坏栈中元素顺序，那么把里面的元素pop出来，最后一个被pop出来的元素，就是比3小的最大元素，然后把它赋值给2。

同时遍历的过程中，如果发现如果nums[i] < third，那么这说明找到了那个最小元素，也就是1。（也可以提前计算好



举例：

[2, 4, 2, 3, 5]

从后往前遍历，栈中的元素从底向上是 5 3 2，遇到4后，弹出2，3，3就是比模式132中3小的最大元素，那么将“2”赋值为3，停止while，然后往栈里压入4，再往前遍历，2小于3，那么[2,4,3]符合题意

```c++
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int third = INT_MIN;
        stack<int> st; //递减栈，栈中的元素均大于third
        for (int i = nums.size()-1; i >= 0; i--) {
            if (nums[i] < third) return true;
            while (!st.empty() && st.top() < nums[i]) {
                third = st.top(); st.pop();
            }
            st.push(nums[i]);
        }
        return false;
    }
};
```



[参考](https://jjaychen.me/programming/monotone-stack)

两种题型：

- 单向查找
- 双向查找

相关题目：





### 子序列问题

一般使用动态规划来解

因为不要求连续，因此每个状态的时候，都需要考虑前面的所有元素

总结：子序列问题一般都需要二重循环，第一重循环从0到n遍历状态，第二重循环向前找**上一个子序列的结尾**j(0 <= j < i)

- LIS问题 要求nums[i] > nums[j]
- 能构成等差数列的子序列 要求nums[i]在nums[j]基础上构成等差数列 【LeetCode 413】
- 最长回文子串 【LeetCode 516】



【LeetCode 413】等差**子数组**

```c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
      int n = nums.size(), res = 0;
      vector<int> dp(n); //dp[i]表示以i结尾等差数列个数
      for (int i = 2; i < n; i++) {
       	if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) dp[i] = dp[i-1] + 1;
        res += dp[i];
      }
      return res;
    }
};
```



【LeetCode 446】等差子序列 非常好的题目

状态定义：`vector<int, unordered_map<long long, int>>` 表示以nums[i]结尾且公差为key等差数列有多少个

参考 https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/fu-xue-ming-zhu-jie-mi-zi-xu-lie-dong-ta-gepk/

```c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int res = 0;
        int n = nums.size();
        vector<unordered_map<long long, int>> dp(n);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                long long diff = (long long) nums[i] - nums[j];
                dp[i][diff] += dp[j][diff] + 1; //长度为2的数列也会存进来，因此对结果有贡献的只有当j位置有值的情况
                res += dp[j][diff];
            }
        }
        return res;
    }
};
```



【LeetCode 516】

状态转移 ：

`dp[i][j]`表示i到j的最长回文序列长度

s[i] == s[j]   ` dp[i][j] = dp[i+1][j-1] + 2`  也就是首尾元素相等

s[i] != s[j]   ` dp[i][j] =  max(dp[i+1][j], dp[i][j-1])`

需要对i进行逆序遍历

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n+1, vector<int>(n+1));
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (i == j) {
                    dp[i][j] = 1;
                    continue;
                }
                if (s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2;
                else dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
            }
        }
        return dp[0][n-1];
    }
};
```



#### LCS

【LeetCode 143】

动态规划

子序列 - 可以不连续 子数组- 必须连续

一维DP的定义：`dp[i]`表示nums[0:i]想求的结果

二维DP的定义：`dp[i][j]`表示 A[0:i]和B[0:j]匹配结果

在LCS问题中，`dp[i][j]`表示的是`A[0:i-1]`和`B[0:j-1]`的匹配，因为`dp[0][j]`表示的是空字符串的匹配，因此状态定义是0到i-1元素的匹配，因此状态的比较是i-1号元素

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n = text1.size(), m = text2.size();
        vector<vector<int>> dp(n+1, vector<int>(m+1));
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
                else dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[n][m];
    }
};
```



##### LCS -> LIS

【LeetCode 1713】【好题】

直观来看：最小操作次数 = target长度 - 最长自序列长度

假如把arr的每个元素转换为在target的下标数组arr'（忽略没有在target出现的元素），那么也就是需要在arr中找出最长的递增子序列（因为target数组是[0,1,2...]，那么需要在arr'中找出LIS）

```c++
class Solution {
public:
    int minOperations(vector<int>& target, vector<int>& arr) {
        int n = target.size();
        unordered_map<int,int> m;
        for (int i = 0; i < n; i++) {
            m[target[i]] = i;
        }
        vector<int> dp;
        for (int a : arr) {
            if (m.count(a)) {
                int val = m[a];
                auto it = lower_bound(dp.begin(), dp.end(), val);
                if (it != dp.end()) *it = val;
                else dp.push_back(val);
            }
        }
        return n - dp.size();
    }
};
```





#### LIS

##### 动态规划：$$O(N^2)$$

dp[i]表示前i个数最长递增子序列长度，递推式是`dp[i] = max(dp[i], dp[j]+1)`

```c++
int lengthOfLIS(vector<int>& nums) {
  int res = 0, n = nums.size();
  vector<int> dp(n, 1);
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = max(dp[i], dp[j]+1);
      }
    }
    res = max(res, dp[i]);
  }
}
```

##### 贪心 + 二分： $$O(NlgN)$$​

https://blog.csdn.net/u012505432/article/details/52228945

贪心：让子序列增长的尽快慢，也就是子序列的最后一个数字尽可能小

其实也是对方法一的优化：原来的内层循环是需要线性遍历得到dp[k]，优化为重新设计状态，把dp设计为一个有序列表，这样可以用二分来遍历[0, k)

`dp[i]`表示：长度为i+1子序列末尾元素值

注意dp数组具有递增性：也就是当子序列长度越长，末尾元素肯定越大

> 反证法的简单证明：
>
> 假如i < j，假设dp[i] > dp[j]，那么从dp[j]表示的序列中删掉j-i个元素，使其变为长度i+1的序列，假如此时末尾值为a，那肯定a < dp[j]，而dp[i] > dp[j]，那么a < dp[i]，这样不符合每次选择最小元素的原则，矛盾

状态转移：

每次遍历过程中：找目标为`nums[i]`的元素，如果不存在，那么可以把`nums[i]`放在序列的最后面，相当于序列长度++；如果存在，那么需要对这个元素完成替换，因为需要尽可能替换为小的元素

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
      int n = nums.size();
      vector<int> dp;
      for (int i = 0; i < n; i++) {
        auto it = lower_bound(dp.begin(), dp.end(), nums[i]);
        if (it != dp.end()) {
          *it = nums[i];
        } else dp.push_back(nums[i]);
      }
      return dp.size();
    }
};
```

手动二分：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] tails = new int[nums.length];
        int res = 0;
        for(int num : nums) {
            int i = 0, j = res;
            while(i < j) {
                int m = (i + j) / 2;
                if(tails[m] < num) i = m + 1;
                else j = m;
            }
            tails[i] = num;
            if(res == j) res++;
        }
        return res;
    }
}
```

##### 二维LIS问题

【LeetCode 354】



#### 最长回文子串【LeetCode 516】

这道题目的比较巧的解法是将字符串翻转，然后求两个字符串的LCS

常规思路就是dp

```c++

```





### 子数组问题

【LeetCode 581】

主要是对题目的理解，这个数组可以分为三部分，A，B，C，A和C都是有序的，中间的B是无序的，所以只要找出B的左右边界即可

有下面两种做法：

#### O(NlogN)

对nums拷贝一个数组，然后进行排序。然后对排序后的数组和原数组的左右两边分别进行比对，找出边界

需要注意的是如果不提前判断nums是否有序，需要在后面的while中对l和r进行范围限制

```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int res = 0, n = nums.size();
        vector<int> sortedNums = nums;
        sort(sortedNums.begin(), sortedNums.end());
        int l = 0, r = n-1;
        // if (sortedNums == nums) return 0;
        while (l <= r && sortedNums[l] == nums[l]) l++;
        while (l <= r && sortedNums[r] == nums[r]) r--;
        return r - l + 1;
    }
};
```

#### O(N)

核心思想和上面的方法类似，不过是用一个mx和mn表示最大和最小值

因为左边的最大值需要小于右边的最小值

因此从左右两边分别遍历（代码上可以在一次循环里完成），以左边为例，从左向右遍历，升序正常，如果遇到降序就更新右边界。从右向左遍历，遇到升序就更新左边界

```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
      int n = nums.size();
      int mx = INT_MIN, mn = INT_MAX;
      int l = -1, r = -1;
      for (int i = 0; i < n; i++) {
        mx = max(mx, nums[i]);
        mn = min(mn, nums[n-i-1]);
        if (mx > nums[i]) r = i;
        if (mn < nums[n - i - 1]) l = n - i - 1;
      }
      return (r == -1) ? 0 : r - l + 1;
    }
};
```





### 表达式问题（遇到括号想栈和递归）

总结：

##### 总结：**括号类问题的处理方法就是栈或者递归**

无括号：遇到乘除立即算，遇到加减先入栈（遇到乘除，栈顶元素和当前元素进行运算，而如果是加减，把数字入栈或者取反后入栈）

注意：C++和Java的地板除法是向零取整 eg: -3 / 2 = -1

##### 类型1：加减法，括号

没有运算优先级的比较

遇到左括号的时候，把当前结果和左括号前的符号压入栈，然后把括号里的式子当成一个完整的式子来计算，遇到右括号的时候，给括号内的运算结果加上符号，然后加上栈里弹出来的值

```c++
stack<int> st;
int res = 0, sign = 1;
for (int i = 0; i < s.size(); i++) {
  char chr = s[i];
  switch(chr) {
    case '+':
      sign = 1;
    	break;
    case '-':
      sign = -1;
      break;
    case '(':
      st.push(res);
      st.push(sign);
      res = 0;
      sign = 1;
      break;
    case ')':
      res *= st.top(); st.pop();
      res += st.top(); st.pop();
      break;
    case ' ':
      break;
    default:
      int num = 0;
      while (i < n && chr >= '0') {
        num = num * 10 + chr - '0';
        i++;
      }
      res += sign * num;
      i--;
  }
  return res;
}
```

另一种思路，直接把括号内的部分当成一个式子来算，也就是用递归

```c++
class Solution {
public:
    int calculate(string s) {
        int res = 0, num = 0, sign = 1, n = s.size();
        for (int i = 0; i < n; ++i) {
            char c = s[i];
            if (c >= '0' && c <= '9') {
                num = 10 * num + (c - '0');
            } else if (c == '(') {
                int j = i, cnt = 0;
              	for (; i < n; i++) {
                  if (s[i] == '(') cnt++;
                  if (s[i] == ')') cnt --;
                  if (cnt == 0) break;
                }
              num = calculate(s.substr(j+1, i-j+1));
            }
            if (c == '+' || c == '-' || i == n - 1) {
                res += sign * num;
                num = 0;
                sign = (c == '+') ? 1 : -1;
             } 
        }
        return res;
    }
};
```

##### 类型二：加减乘除【LeetCode227】





##### 类型三：加减乘除括号【LeetCode772】



【LeetCode 726】比较庞大的模拟题，没有亲手写，看看思路

这个的解法写的很好 https://github.com/grandyang/leetcode/issues/726







### 空间有限制的处理方法

不借用辅助的数据结构，一般是用参数所提供的数据结构来进行

有一个原地算法，

想到的几种处理思路：

- 借助int是32位，可以用位运算

- 借助参数数组，比如可以用矩阵的第一行第一列作为存储，再用常数变量存储第一行第一列

  - 【LeetCode 73】

    空间复杂度：O(M+N) 我的一般思路是用两个数组，维护有哪些行和列有0，然后再遍历一遍matrix置0

    空间复杂度：O(1) 用两个变量记录第一行和第一列是否有0，然后再用第一行第一列记录其他行和列的情况

- 通过多次swap

  - 将一个数组逆序，就可以不断做交换而达成目标

  ```c++
  for (int i = 0; i < int(n / 2); i++) {
    swap(array[i], array[n-i-1]);
  }
  ```

  

### 数字类型题

丑数：只包含质因数 `2`、`3` 和/或 `5` 的正整数。

【LeetCode 264】

可以用三指针做法，注意规律就是后面的丑数就是前面的丑数再乘2/3/5

因此每次将三者的最小值加入结果集合即可

Ps: 另外一种方法是用优先队列自然排序，不过每次遍历的时候需要先判断是否队列头有重复元素（这个没懂）

https://www.cnblogs.com/grandyang/p/4743837.html



### 排序类问题

类型1：组成最大数

【LeetCode 179】

```c++
sort(strs.begin(), strs.end(), [](string &a, string &b) {
  return a + b > b + a;
})
```

<u>注意点是最后需要判断是否首位为0</u>

#### 快速排序

核心：每次把小于基准点的放在左边，把大于基准点的放在右边

过程：把数组分成两部分；对两部分分别进行快速排序；不需要合并，因为已经有序

和归并的区别：归并是直接分成两等份，而快速排序保证了左半边比右半边小这样一种相对大小关系

实现有两大步：哨兵划分和递归

```c++
void quickSort(vector<int> arr, int l, int r) {
  if (l >= r) return;
  int i = l, j = r;
  while (i < j) {
    int piovt = arr[l]; //选择最左边的元素作为哨兵
    while (i < j && arr[i] < piovt) i++; //找到第一个不满足左半部分小于哨兵元素的数
    while (i < j && arr[j] > piovt) j--; //找到第一个不满足右半部分大于哨兵元素的数
    swap (arr[i], arr[j]);
  }
  swap(arr[l], arr[i]); //最后把pivot放在中间
  quickSort(arr, l, i - 1);
  quickSort(arr, i + 1, r);
}
```

<img src="../../../../学习/笔记合集/img/image-20210903161702762.png" alt="image-20210903161702762" style="zoom:33%;" />

快排妙用：【LeetCode 剑指Offer40】

[参考](https://leetcode-cn.com/leetbook/read/illustration-of-algorithm/ohwddh/)

如果某次哨兵划分后，哨兵刚好在第k+1位，那么返回前k位即为题意要求

那么每次进行哨兵划分后，根据哨兵所在的位置i：

- i < k  递归右子数组找到k位置
- i < k 递归左子数组找到k位子
-  i == k 返回前k个数字即可





### 前缀树

【LeetCode 208】

三个性质：

根节点没有字符，除根节点外每个节点包含一个字符

根节点某个节点，字符连接起来就成为节点对应的字符串

每个节点的子节点包含的字符不同(兄弟之间不一样

)

```c++
class TrieNode {
public:
    vector<TrieNode*> children;
    TrieNode() : children(26) { //注意这里的初始化只能放在构造方法的列表里
        for (TrieNode* node : children) {
        	node = nullptr; //这里可能有空子节点，所以是nullptr
        }
    }
    bool isWord = false;
};

class Trie {
private:
    TrieNode* root;
public:
    /** Initialize your data structure here. */
    Trie() {
        root = new TrieNode(); //注意一下指针初始化的方式，这里是需要初始化实际的节点，所以用创建对象
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        TrieNode* p = root;
        for (char c : word) {
            int i = c - 'a';
            if (!p->children[i]) p->children[i] = new TrieNode();
            p = p->children[i];
        }
        p->isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        TrieNode* p = root;
        for (char c : word) {
            int i = c - 'a';
            if (!p->children[i]) return false;
            p = p->children[i];
        }
        return p->isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        TrieNode* p = root;
        for (char c : prefix) {
            int i = c - 'a';
            if (!p->children[i]) return false;
            p = p->children[i];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

实际应用：自动补全单词，比如输入法

TODO: LeetCode 1707





###  随机数问题

【LeetCode 470】

如果直接两个rand7相加，然后拒绝采样，由于每个结果产生的概率不同，比如两个rand7组合产生6和7的概率不同，因此这种方法不行

结论：

- (rand_X - 1) * Y + rand_Y 可以等概率生成[1, X * Y ]随机数
- 当b是a的整数倍，rand_a = rand_b % a + 1
  - 比如已知rand4，rand2 = rand4 % 2 + 1
- 拒绝采样：如果某个数字不在要求的结果范围内，那么可以直接舍弃掉

```C++
class Solution {
public:
    int rand10() {
        while (true) {
            int res = (rand7() - 1) * 7 + rand7();
            if (res <= 40) return res % 10 + 1;
        }
    }
};
```

优化：

在上面的基础上进一步优化的话，那就是把41-49这部分多出来的数也利用好

```C++
public int rand10() {
  while(true) {
    int a = rand7();
    int b = rand7();
    int num = (a-1)*7 + b; // rand 49
    if(num <= 40) return num % 10 + 1; // 拒绝采样
            
    a = num - 40; // rand 9 通过rand9生成rand7
    b = rand7();
    num = (a-1)*7 + b; // rand 63
    if(num <= 60) return num % 10 + 1;
            
    a = num - 60; // rand 3 通过rand3生成rand7
    b = rand7();
    num = (a-1)*7 + b; // rand 21
    if(num <= 20) return num % 10 + 1;
  }
}
```



### 罗马数字和十进制的相互转化

【LeetCode13】罗马->整数

我的处理方法是一次取两个，比如AB，如果AB在map，那么加上对应数字，如果不是，那就i++继续遍历

```c++
class Solution {
public:
    int romanToInt(string s) {
        int res = 0, n = s.size();
        unordered_map<char, int> m= {
            {'M', 1000},
            {'D', 500},
            {'C', 100},
            {'L', 50},
            {'X', 10},
            {'V', 5},
            {'I', 1},
        };

        for (int i = 0; i < n; i++) {
            int cur = m[s[i]];
            if (i < n-1 && cur < m[s[i+1]]) {
                res -= cur;
            } else {
                res += cur;
            }
        }
        return res;
    }
};
```

【LeetCode12】整数->罗马

构造一个递减map，包含所有可能出现的罗马数字单元，依次遍历，找到不大于当前整数的最大罗马数字，加到结果里

```c++
#include<algorithm>
class Solution {
public:
    static bool cmp(pair<int, string> p1, pair<int, string> p2) {
        return p2.first < p1.first;
    }

    string intToRoman(int num) {
        string res = "";
        vector<pair<int, string>> m= {
            {1000, "M"},
            {900, "CM"},
            {500, "D"},
            {400, "CD"},
            {100, "C"},
            {90, "XC"},
            {50, "L"},
            {40, "XL"},
            {10, "X"},
            {9, "IX"},
            {5, "V"},
            {4, "IV"},
            {1, "I"}
        };

        for (auto [number , roman] : m) {
            while (num >= number) {
                res += roman;
                num -= number;
            }
        }
        return res;
    }
};
```







### 括号匹配类题目

经典验证括号的方法：遇到左括号+1，右括号-1，当计数器出现负数，或者遇到右括号时计数器为0，都返回false

【LeetCode1190】

我的思路是找出所有括号的位置，然后依次往外进行反转

题解的思路是用栈，处理括号类问题一般都会用到栈

一个字符串分为三部分，分别进行处理 `a(bc)d`

遇到左括号，把a放入栈

遇到右括号，把里面的内容反转，处理后的字符串是栈的顶端加上反转后的字符串，最后再加上括号右边的内容

```c++
class Solution {
public:
    string reverseParentheses(string s) {
        string str;
        stack<string> st;
        for (char & c : s) {
            if (c == '(') {
                st.push(str); 
                str = "";
            } else if (c == ')') {
                reverse(str.begin(), str.end());
                str = st.top() + str;
                st.pop();
            } else {
                str.push_back(c);
            }
        }
        return str;
    }
};
```



【LeetCode 678】

括号匹配类问题还需要注意括号出现的先后顺序，因此栈中一般存储下标

这道题使用左括号栈和星号栈，先为右括号完成匹配，然后再给剩下的左括号匹配星号，只要每个左括号下标都有一个下标大于它的星号，即可满足题意

```c++
class Solution {
public:
    bool checkValidString(string s) {
        int optionNum = 0;
        stack<int> lSt, aSt;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                lSt.push(i);
            } else if (s[i] == ')') {
                if (!lSt.empty()) lSt.pop();
                else if (!aSt.empty()) aSt.pop();
                else return false;
            } else aSt.push(i);
        }
        // 现在所有)匹配完毕，把剩余的(和*匹配
        while (!lSt.empty() && !aSt.empty()) {
            int l = lSt.top(), a = aSt.top();
            if (l > a) return false;
            lSt.pop(); aSt.pop();
        }
        return lSt.empty();
    }
};
```

其他做法：

- 正向遍历一次，反向遍历一次，遍历的时候分别把*当成左括号和右括号

  ```c++
  class Solution {
  public:
      bool checkValidString(string s) {
          int left = 0, right = 0, n = s.size();
          for (int i = 0; i < n; ++i) {
              if (s[i] == '(' || s[i] == '*') ++left;
              else --left;
              if (left < 0) return false; //即使全部*变为左括号，也无法匹配右括号
          } //此时left>0还不能返回false，因为多的左括号可能是*变的
          if (left == 0) return true;
          for (int i = n - 1; i >= 0; --i) {
              if (s[i] == ')' || s[i] == '*') ++right;
              else --right;
              if (right < 0) return false; //即使全部*变为右括号，也无法匹配左括号
          }
        // 这时候right = 0肯定是true，right>0也为true的原因是正向遍历的时候左括号多了，本身如果就多的左括号会在反向遍历时候检测出来，如果没有，则说明多的左括号是星号变的。所以当星号为空的时候，正好就是合法的
          return true;
      }
  };
  ```

- 用DP来做

  `dp[i][j]`表示前i个字符(下标从1开始)，能否与j个右括号形成匹配（j个右括号不在前i个里面）

  最后返回`dp[n][0]`

  ```java
  class Solution {
      public boolean checkValidString(String s) {
          int n = s.length();
          boolean[][] f = new boolean[n + 1][n + 1];
          f[0][0] = true;
          for (int i = 1; i <= n; i++) {
              char c = s.charAt(i - 1);
              for (int j = 0; j <= i; j++) {
                  if (c == '(') {
                      if (j - 1 >= 0) f[i][j] = f[i - 1][j - 1]; //当前的(和 多一个的右括号完成匹配
                  } else if (c == ')') {
                      if (j + 1 <= i) f[i][j] = f[i - 1][j + 1]; //f[i-1][j+1]多的一个右括号放在f[i][j]
                  } else {
                      f[i][j] = f[i - 1][j];
                      if (j - 1 >= 0) f[i][j] |= f[i - 1][j - 1];
                      if (j + 1 <= i) f[i][j] |= f[i - 1][j + 1];
                  }
              }
          }
          return f[n][0];
      }
  }
  ```

- 比较巧妙的解法：

  需要记录一个得分区间

  l表示最低得分，r表示最高得分（换种说法，l是左括号最少多少个，r是左括号最多多少个）

  ```c++
  class Solution {
  public:
      bool checkValidString(string s) {
          int low = 0, high = 0;
          for (char c : s) {
              if (c == '(') {
                  ++low; ++high;
              } else if (c == ')') {
                  if (low > 0) --low;
                  --high;
              } else {
                  if (low > 0) --low;
                  ++high;
              }
              if (high < 0) return false; // 最高的还小于0，那肯定false了
          }
          return low == 0;
      }
  };
  ```

换种写法：

```java
class Solution {
    public boolean checkValidString(String s) {
        int l = 0, r = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                l++; r++;
            } else if (c == ')') {
                l--; r--;
            } else {
                l--; r++;
            }
            l = Math.max(l, 0); //如果当前序列不合法，后面肯定不合法了，所以需要归零
            if (l > r) return false; //说明右括号太多，必然不合法
        }
        return l == 0;
    }
}
```



相关题目：

20 22 32 301





### 进制转换类

【LeetCode 168】

这道题相当于十进制和26进制的转换

```c++
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string res;
        while (columnNumber--) { //这里递减就是因为把字母区间转化到[0,25]区间中
            res += columnNumber % 26 + 'A';
            columnNumber /= 26;
        }
      //等价于
      /**
        while (n > 0) {
            ans += (n - 1) % 26 + 'A';
            n = (n - 1) / 26;
        }
       **/
        reverse(res.begin(), res.end());
        return res;
    }
};
```

注意：这里的`columnNumber--`非常巧妙，同时也解决了当columnNumber%26等于0的时候应该取Z而不是@的情况

$$A@Y: 701 = 1 \times 26 ^ 2+ 0 \times 26 ^1 + 25 \times 26 ^ 0$$

$$ZY: 701 = 26 \times 26 ^1 + 25 \times 26 ^ 0$$

问题在于十进制转到26进制时，每位不能出现0，取值范围是1-26对应A-Z，而对26取模的结果是0-25，因此当26/26的时候，还需要进位，导致有一位为0。

因此在同模和同除操作时，需要先-1



换个思路来看：

a1 × 26º + a2 × 26¹ + a3 × 26² + a4 × 26³ + ... = n

其实就是在做两边同时除以26的过程，每一次除，都会消掉最低项，但如果是26的话，结果为1，消除不掉最低项。因此两边同时-1。



### 相关排序的应用

桶排序【LeetCode 451】

计数排序 【LeetCode 274】【LeetCode 1846】

线性的算法







### 哈希表

主要有几点用途：

- 能以O(1)找到需要的元素，减少一次for循环
  - 经典两数之和问题：例如要找符合和为target的两个数，可以遍历出一个数 x，然后看哈希表中是否存在target - x
- 记录元素出现次数
- 经常和前缀和一起出现



一般暴力遍历超时的话，可以考虑哈希表是否可以减少一个数量级的时间复杂度



经典两数和：for循环 + hash

三数和：for循环 + 双指针



【LeetCode 1711】

如果直接两层遍历判断是否是2的幂，会超时

换一种思路是枚举可能的2的幂，然后采用哈希进行判断另一个数字

这样

```c++
class Solution {
public:
    int countPairs(vector<int>& deliciousness) {
        int MOD = pow(10, 9) + 7;
        int n = deliciousness.size();
        long long res = 0;
        int maxSum = *max_element(deliciousness.begin(), deliciousness.end()) * 2;
        unordered_map<int, int> m;
        for (int i = 0; i < n; i++) {
            for (int j = 1; j <= maxSum; j *= 2) { //枚举结果
                if (m.count(j - deliciousness[i])) res = (res + m[j-deliciousness[i]]) % MOD; //注意提前取余
            }
            m[deliciousness[i]]++;
        }
        return (int) res % MOD;
    }

    bool is2Power(long long n) {
        return (n & (n-1)) == 0;
    }
};
```





### 特殊算法

Boyer-Moore 投票算法

【LeetCode 面试题17.10】

算法的本质是：由于候选因素出现的次数多于一半，那么每次消去不同的元素，最后剩下的肯定是侯选元素

在选出侯选元素后，还需要进行验证



具体实现是相同的数，cnt + 1，不同的数，cnt - 1

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1, cnt = 0; //随机挑选一个作为候选元素
        for (int num : nums) {
          if (cnt == 0) candidate = num;
          if (candidate == num) cnt++;
          else cnt--;
        }

        cnt = 0;
        for (int num : nums) {
            if (num == candidate) cnt++;
        }
        return (cnt > nums.size() / 2) ? candidate : -1;
    }
};
```























