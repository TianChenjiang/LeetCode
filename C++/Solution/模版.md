#### 判断质数：

```c++
bool isPrime(int num) {
  if (num <= 1) return false;
  if (num == 2) return true;
  for (int i = 2; i * i <= num; i++) { //注意这里能取等号
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}
```



#### 买股票问题：

只允许一次交易：遍历更新最小值，并取最大收益即可

不限制交易次数：遍历，只要能产生收益就加进来，返回累加和（一天内可以买或者卖）

限制交易次数：

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<int> sell(k+1,0);
        vector<int> buy(k+1,INT_MIN);
        for(int price : prices)
        {
            for(int i = 1;i <= k; i++) {
                buy[i] = max(buy[i],sell[i-1] - price);
                sell[i] = max(sell[i],buy[i] + price);
            }
        }
        return sell[k];
    }
};
```

注：内层循环以k=2比较好理解：

b1 = max(b1, -p);
s1 = max(s1, b1 + p);
b2 = max(b2, s1 - p);
s2 = max(s2, b2 + p);

这里的s1相当于sell[i-1]，b2相当于buy[i]，用自然语言解释就是(b2)是取b2和(前一次交易卖的利润-当前price)的最大值，s2就是取sell2和上一次买的股票加上以当前价格卖出的最大值

参考：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1).

限制最大交易次数：

直接令最大交易次数`k = min(k, n/2)`即可 



-

#### 滑动窗口问题

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

注意：内循环和外循环都是：先更新sum/res，再更新指针

> 以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

ps：记录一下，https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/，没有看懂

![image-20210205194837544](../../../../学习/笔记合集/img/image-20210205194837544.png)

例：LeetCode424

> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
>
> 注意：字符串长度 和 k 不会超过 104。
>
> ```
> 输入：s = "ABAB", k = 2
> 输出：4
> 解释：用两个'A'替换为两个'B',反之亦然。
> ```

```c++
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2) {
        return p1.second < p2.second;
    }

    int characterReplacement(string s, int k) {
        int l = 0, r = 0, n = s.size();
        int res = 0, maxCnt = 0;
        int counts[26];
        memset(counts, 0, sizeof(counts));
        while (r < n) {
            counts[s[r] - 'A']++;
            // maxCnt = max_element(m.begin(), m.end(), cmp)->second;
            maxCnt = max(maxCnt, counts[s[r] - 'A']);
            while (r - l + 1 - maxCnt > k) {
                counts[s[l] - 'A']--;
                l++;
            }
            res = max(res, r - l + 1);
            r++;
        }
        return res;
    }
};
```



例：LeetCode 1004

关键是做题意的转换

**最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度**  -> 找一个包含K个0的最长子数组



滑动窗口题目简单版本：

某些简单题目，比如最大连续1的个数，这种不需要用双指针，将l记录非0数字，r向右移动即可





#### 盛雨水问题

LeetCode 11 

`res = max(res, 短板 * 板子之间距离)`

需要注意的就是移动左指针，还是右指针

因为板子之间距离必然减小，所以只有移动短板才可能变大，移动长板的话，那结果肯定小于等于原来的res





















