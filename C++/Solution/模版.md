#### 二分法

减治：每次排除不符合要求的元素，搜索空间持续减少

标准模版：

```c++
int l = 0, r = nums.size()-1;
while (l < r) { //相等就退出
  int mid = l + (r - l) / 2; //也可以 long mid = (long)l + r >> 1
  if (nums[mid] <= target) {
    r = mid; //说明答案在[l, mid]区间
  } else {
    l = mid + 1; //说明答案在[mid + 1, l]区间
  }// while的出口是大于targetd的最小元素
  return l; //此时 l == r，区间缩为一个点，l-1是不大于target的最大元素
}
```

网上总结关于二分的几种类型 https://www.cnblogs.com/grandyang/p/6854825.html

相关题目：

【LeetCode 852】找出极值点

我的写法：把原来的l = mid + 1和r = mid换为l++和r--

```c++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n = arr.size();
        int l = 0, r = n-1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] >= arr[r]) {
                r--;
            } else {
                l++;
            }
        }
        return l;
    }
};
```

官方写法：

```c++
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n = arr.size();
        int l = 0, r = n-1;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (arr[mid] < arr[mid+1]) l = mid + 1;
            else r = mid;
        }
        return l;
    }
};
```



#### 动态规划

非常非常非常好的归纳：https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85（在参考文件夹有拷贝）

记忆化递归：自顶向下（大问题 -> 小问题）也就是从目标求起

动态规划：自底向上（一般来说，写出记忆化递归，就能转成动态规划）

[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/fu-xue-ming-zhu-cong-ji-yi-hua-di-gui-tu-rqwy/)

经典好题：

##### 【403】青蛙过河

关键点是在每块石头上的关注点是当前是第几块石头，上一个是怎么来的，因此把这两个作为一个状态，也就是`dp[i][j]`

表示在第i块石头上，并且上一次的跳跃距离是j

因此只需要一个二重遍历，当走到第i块石头，再一步步往回遍历，看是否能从j石头跳到这里，判断的标准是

`dp[i][k] = dp[j][k-1] || dp[j][k] || dp[k+1] `

这时候如果i==n-1并`dp[i][k]`为true的话，那说青蛙能跳过来



需要注意的就是可以进行剪枝优化：

- 在第i块石头上，离它最近的石头的距离不能超过i，因为在第i-1的石头上，最多能跳（i-1) +1 
- 两个石头i和j距离超过j+1时，青蛙必定无法到达终点

```c++
class Solution {
public:
    bool canCross(vector<int>& stones) {
        // dp[i][j]表示当前第i块石头，是上一次跳的距离为j跳过来的
        int dp[2001][2002];
        memset(dp, 0, sizeof(dp));
        int n = stones.size();
        dp[0][0] = 1; //这个是因为第一步只能跳一个单位
        for (int i = 1; i < n; i++) {
            if (stones[i] - stones[i-1] > i) return false;
        }
        // 最后需要判断 dp[i-1][k]是否为true
        for (int i = 1; i < n; i++) {
            for (int j = i - 1; j >= 0; j--) {
                int dis = stones[i] - stones[j];
                if (dis > j + 1) break; //从j跳到i，最多只可能跳j+1，距离大于j+1，那必不可能
                dp[i][dis] = dp[j][dis-1] || dp[j][dis] || dp[j][dis+1];
                if (i == n-1 && dp[i][dis]) return true;
            }
        }
        return false;
    }
};
```



##### 打家劫舍（不能取到连续元素的一类问题）

变式：【LeetCode 740】通过将数组的相同元素进行聚合，就转换为打家劫舍问题

```c++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int aggregateNums[10001], dp[10001];
        memset(aggregateNums, 0 ,sizeof(aggregateNums));
        int cnt = 0;
        for (int i = 0; i < nums.size(); i++) {
            aggregateNums[nums[i]] += nums[i];
            cnt = max(cnt, nums[i]);
        }
        //dp[i]表示数字i前获得的最大点数，需要注意的就是这里的两个数组都当成hash来用了，下标也对应着元素Id
        dp[0] = 0, dp[1] = aggregateNums[1];
        for (int i = 2; i <= cnt; i++) {
            dp[i] = max(dp[i-1], dp[i-2] + aggregateNums[i]);
        }
        return dp[cnt];
    }
};
```



##### 打印机问题

【LeetCode 664】

这个题需要注意的是**倒序遍历**，因为需要确保`dp[i][k]` 和 `dp[k+1][j]`都已经被计算

```c++
class Solution {
public:
    int strangePrinter(string s) {
        int n = s.size();
        int dp[101][101];
        // dp[i][j]表示i到j区间内的打印次数
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) dp[i][j] = dp[i][j-1];
                else {
                    // i到j需要分为两部分，取最小值
                    int tmp = INT_MAX;
                    for (int k = i; k < j; k++) { //k从i开始取的好处是，假如i = j - 1，不用做特殊处理
                        tmp = min(tmp, dp[i][k] + dp[k+1][j]);
                    }
                    dp[i][j] = tmp;
                }
            }
        }
        return dp[0][n-1];
    }
};
```



【LeetCode 1269】

关键在于dp数组的定义，`dp[i][j]`表示经过i个步骤后到达索引j的方案

然后可能不动，向左，向右到达当前状态

（有个问题是好像直接用正常的数组就会overflow）

```c++

```



#### 区间DP 问题

从小到大枚举区间长度和枚举区间的左端点

需要注意的是题解中令石头的下标从1开始，这个做法比较巧，可以避免有些步骤中在取前一块石头时候，如果正好是第一块石头，则会出现错误

转移方程如下：定义`dp[i][j]`表示在[i, j]区间中，在最优策略下，先手和后手的最大差值

- 取的是左边的石头，差值变为 `piles[l-1] - dp[l+1][r]` ，`dp[l+1][r]`表示后手在[l+1,r]区间内取石头
- 取的是右边的石头，差值变为 `piles[r-1] - dp[l][r-1]` ，`dp[l+1][r]`表示后手在[l+1,r]区间内取石头

由于都是最优策略，因此选择二者的最大值

如果最后`dp[1][n]`大于0，那么表示先手和后手的差值为正，也就是先手胜

【LeetCode877】

```c++
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int n = piles.size();
        vector<vector<int>> dp(n + 2, vector<int>(n + 2));
        // dp[i][j]表示在区间[i,j]中，先手和后手的最大差值
        for (int len = 1; len <= n; len++) {
            for (int l = 1; l + len - 1 <= n; l++) {
                // r - l + 1 = len
                int r = len + l - 1;
                int choice1 = piles[l-1] - dp[l+1][r]; //左边选石头
                int choice2 = piles[r-1] - dp[l][r-1];
                dp[l][r] = max(choice1, choice2);
            }
        }
        return dp[1][n];
    }
};
```

【LeetCode 1449】

【LeetCode 879】







#### 背包问题

判定：给定一些物品，从中进行选择，以达到最大价值或者特定价值

本质上是组合问题，因为被选定的物品之间没有关系，只需要选择，以达到全局最优或者特定状态

https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85

分为三类

- 组合问题
  - 【377】 【494】 【518】
  - `dp[i] += dp[i-num]`
  - 需要考虑是否结果元素中的顺序问题
- True False 问题
  - 【139】 【416】
  - `dp[i] = dp[i] || dp[i-num]`
- 最大最小问题
  - 【474】 【322】
  - `dp[i] = min(dp[i], dp[i-num]+1)` or `dp[i] = max(dp[i], dp[i-num]+1)`

注意事项：

0-1背包 vs 完全背包 ： 元素是否可以**重复使用**

背包问题技巧：

（[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/)）

- 0-1背包

  ```c++
  for (int num : nums) {
    for (int i = target; i > num - 1; i--)
  }
  ```

- 完全背包

  ```c++
  for (int num : nums) {
    for (int i = num; i < target + 1; i++)
  }
  ```

- 组合问题且考虑元素顺序

  ```c++
  for (int i = 1; i < target+1; i++) {
    for (int num : nums) {
      
    }
  }
  ```




一定需要明确背包问题的使用场景，这道题如果用背包的话可以做出来，但是会超时。

这道题只要排序后，采用贪心思想，取最前面的几个就可以了

换一种角度思考：

背包问题一般是解决两个维度相互牵制的问题，如背包容量和背包价值，比如选择重量最轻的放背包，但价值不会迅速增长，如果选择价值高的，但容量可能消耗的最多。所以只对某个维度做贪心的话，不是全局最优解。（应该对单位价值做贪心）



【LeetCode 1833】

而在这道题中，要求最大数量，而每个物品的贡献度都是1，优先选择价格低的能让剩余金额变多



##### 0-1背包大总结

复杂度 O(N * C)

最基本的问题描述：

在一个容量为n的背包，要用这个背包装下物品的价值最大，每个物品有两个属性，体积w和价值v

具体分析：

对于第i个物品，可能放入背包，也可能不放入

定义二维数组`dp[i][j]`表示：前i件物品，在体积<u>不超过j</u>的情况下能获得的最大价值

- 不放入的话：前i件的最大价值也就是前i-1的最大价值 也就是`dp[i][j] = dp[i-1][j]`
- 放入的话：还需要加上当前价值 `dp[i][j] += dp[i-1][j-coins[i-1]]`

```c++
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
  	vector<vector<int>> dp(N+1, vector<int>(W+1));
    for (int i = 1; i <= N; i++) {
      int value = values[i-1], weight = weights[i-1];
      for (int j = 0; j <= W; j++) {
        dp[i][j] = dp[i-1][j];
        if (j >= weight) dp[i][j] = max(dp[i][j], dp[i-1][j-weight] + value);
      }
    }
  	return dp[N][W];
}
```

几个写 代码层面的注意点：

- 外层遍历初始值是1，因为当前状态和前面状态有关
- 内部遍历的目的值应该能取等于号，比如这里的`j <= W`，因为dp数组的定义是不超过j
- 需要注意最后求的是方案数还是最大值，这个决定了状态转移方程是什么样的



利用滚动数组的方法优化：

由于第i个物品的状态只和i-1有关，因此可以对数组进行降维。但需要注意的是，内部遍历必须是倒序遍历。原因是假如正序遍历，会先计算`dp[i][0]` 一直到`dp[i][weight]`，这部分会把dp[i-1]的进行覆盖，等后面满足j >= weight条件后，会需要`dp[i-1][j-weight]`的值，正序的话这部分值已经被替换为`dp[i-1][j-weight]`，无法满足

```c++
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
  	vector<int> dp(W+1);
    for (int i = 1; i <= N; i++) {
      int value = values[i-1], weight = weights[i-1];
      for (int j = W; j >= 1; j--) {
        if (j >= weight) dp[j] = max(dp[j], dp[j-weight] + value);
      }
    }
  	return dp[N][W];
}
```



相关题目：

重要的是识别出题目可以转化为01背包问题，然后识别出相关的物品和限制

【LeetCode 494】

数学推导：

已知：

Sum(P) - Sum(N) = target

Sum = Sum(P) + Sum(N)



Sum(P) + Sum(N) - Sum(N) -Sum(N) = target

合并 Sum - 2*Sum(N) = target

最后得到 Sum(N) = (Sum - target) / 2

同理也可以找出Sum(P)和sum target之间的关系

通过数学推导可以转化为要在数组中找出一个子集，和恰好为sum/2的方案数

状态转移方程为 $$f[i][j] = f[i-1][j] + f[i-1][j-nums[i-1]]$$



需要注意的是先要排除不满足题意的条件`if (sum < target || (target + sum) % 2 != 0) return 0;` （因为必须都是整数，才能满足那个等式）

代码如下：

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
      int n = nums.size(), sum = 0;
      sum = accumulate(nums.begin(), nums.end(), 0);
      // 找到一个子集，满足和恰好为(sum-target)/2
      int nTarget = (sum - target) / 2;
      if (sum < target || (sum - target) % 2 != 0) return 0;
      vector<int> dp(nTarget + 1);
      dp[0] = 1;
      for (int i = 1; i <= n; i++) {
        int num = nums[i-1];
        for (int j = nTarget; j >= num; j--) {
          dp[j] += dp[j - num];
        }
      }
      return dp[nTarget];
    }
};
```





【LeetCode 1049】

关键是如何转化为背包问题







【LeetCode 879】



##### 完全背包问题

与01背包的区别就是元素是否能重复使用

状态转移方程：

$$dp[i][j] = max(dp[i-1][j],  dp[i-1][j-k*w[i]] + k*v[i])$$

一维优化：

$$dp[j] = max(dp[j],dp[j-w[i]] + v[i])$$ j

写代码的注意点：

- 注意题目是恰好还是不超过

  > 背包有「不超过」和「恰好」的状态定义，其实其只有初始化的不同。
  >
  > 从状态合法性出发考虑初始化即可。
  >
  > 我的代码里对「恰好」的定义体现在 f[0] = 0 其余为负无穷

- 内部遍历为正序

  (这样做的原因是将成本和价值进行抽象，然后进行换元法；有点类似于把多个一样的物品看作一种)

[参考](https://leetcode-cn.com/problems/coin-change-2/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv/)

【LeetCode 518】

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
      int n = coins.size();
      vector<vector<int>> dp(n+1, vector<int>(amount+1));
      dp[0][0] = 1;
      for (int i = 1; i <= n; i++) { //物品的遍历
        int coin = coins[i-1];
        for (int j = 1； j <= amount; j++) {  //目标金额的遍历
          for (int k = 1;  k * coin <= j; k++)   { //某个钱使用次数的遍历
            	dp[i][j] += dp[i-1][j-k*coin];
            }
        }
      }
      return dp[n][amount]
    }
};
```

通过换元优化法：

可以经过数学推导验证正确性，通俗理解就是将重复的多个物品看成一个整体

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
      int n = coins.size();
      vector<int> dp(amount+1);
      dp[0] = 1;
      for (int i = 1; i <= n; i++) { //物品的遍历
        int coin = coins[i-1];
        for (int j = coin； j <= amount; j++) {  //目标金额的遍历
          dp[j] +=  dp[j-coin];
        }
      }
      return dp[amount]
    }
};
```



【LeetCode1449】

两条规则：

- 数字位数越多越大
- 位数相同，则依次比较位数

具体的，先考虑「数值长度」问题，每个数字有相应选择成本，所能提供的长度均为 11。

问题转换为：有若干物品，求给定费用的前提下，花光所有费用所能选择的最大价值（物品个数）为多少。

每个数字可以被选择多次，属于完全背包模型。

当求得最大「数值长度」后，考虑如何构造答案。

根据规则二，应该尽可能让高位的数值越大越好，因此我们可以从数值 99 开始往数值 11 遍历，如果状态能够由该数值转移而来，则选择该数值。



>背包有「不超过」和「恰好」的状态定义，其实其只有初始化的不同。
>
>从状态合法性出发考虑初始化即可。
>
>我的代码里对「恰好」的定义体现在 f[0] = 0 其余为负无穷



#### 判断质数：

```c++
bool isPrime(int num) {
  if (num <= 1) return false;
  if (num == 2) return true;
  for (int i = 2; i * i <= num; i++) { //注意这里能取等号
    if (num % i == 0) {
      return false;
    }
  }
  return true;
}
```



### DFS

【LeetCode1723】

暴搜：

```c++
class Solution {
public:
    int res = INT_MAX, n, _k;
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int work[13];
        memset(work, 0, sizeof(work));
        n = jobs.size(), _k = k;
        dfs(jobs, 0, work, 0);
        return res;
    }

    void dfs(vector<int>& jobs, int cur, int work[], int maxTime) {
        if (maxTime >= res) return;
        if (cur == n) {
            res = maxTime;
            return;
        }
        for (int i = 0; i < _k; i++) {
            work[i] += jobs[cur];
            dfs(jobs, cur+1, work, max(maxTime, work[i]));
            work[i] -= jobs[cur];
        }
    }
};
```

剪枝优化：

```c++
class Solution {
public:
    int res = INT_MAX, n, _k;
    int minimumTimeRequired(vector<int>& jobs, int k) {
        int work[13];
        memset(work, 0, sizeof(work));
        n = jobs.size(), _k = k;
        dfs(jobs, 0, 0, work, 0);
        return res;
    }

  	// used 分配到第几个工人
    // work数组 工作情况 work[i] = a 表示i号工人工作量为a
    // cur 分配到第几个工作
    // maxTime 当前的最大时间
    void dfs(vector<int>& jobs, int used, int cur, int work[], int maxTime) {
        if (maxTime >= res) return;
        if (cur == n) {
            res = maxTime;
            return;
        }
        if (used < _k) {
            work[used] += jobs[cur];
            dfs(jobs, used+1, cur+1, work, max(maxTime, work[used]));
            work[used] -= jobs[cur];
        }

        for (int i = 0; i < used; i++) { //注意这里只遍历[0, used]
            work[i] += jobs[cur];
            dfs(jobs, used, cur+1, work, max(maxTime, work[i]));
            work[i] -= jobs[cur];
        }
    }
};
```

解析：

优化的关键在于加入if条件，表示先把工作优先分配给没有工作的人，原来的未优化版本的最差情况是所有工作都交给第一个工人

优化后：（这个题的大致目的是尽可能完成平均分配）

if表示分配给没有工作的人，后面的循环表示分配给已经有工作的人。if的分配不需要遍历，因为大家都没有工作时间，所以随便分配一个然后dfs就可以，而后面的循环，本身都有工作时间了，不同分配会有不同的结果，因此需要挨个遍历

<img src="../../../../学习/笔记合集/img/image-20210531114121940.png" alt="image-20210531114121940" style="zoom:33%;" />



### BFS

求最小值两大方法：dp，BFS（迷宫遍历问题）

使用场景： **层次遍历，最短路径问题**

参考：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/

明确和DFS区别：都可以遍历树、图中的所有结点，能力没什么差别，但倾向于更好写，空间复杂度更小的DFS

DFS是递归遍历，BFS用队列遍历

DFS比较简洁，因为递归用了系统的栈





适合解决的问题：遍历树，图，统计无权图到达某个点的方案数（举例：【[LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/)】可以用DFS，BFS解决，也可以用DP解决）



BFS：

```c++
void BFS(TreeNode* root) {
  queue<TreeNode*> q({root});
  while (!q.empty()) {
    TreeNooe* cur = q.top(); q.pop();
    if (cur->left) q.push(cur->left);
    if (cur->right) q.push(cur->right);
  }
}
```

升级版：

<img src="../../../../学习/笔记合集/img/image-20210625120053272.png" alt="image-20210625120053272" style="zoom:33%;" />

```c++
void BFS(TreeNode* root) {
  queue<TreeNode*> q({root});
  while (!q.empty()) {
    int n = q.size(); //n表示这一层的所有结点
    for (int i = 0; i < n; i++) { //层次遍历的话，每个for循环是一层
      TreeNooe* cur = q.top(); q.pop();
    	if (cur->left) q.push(cur->left);
    	if (cur->right) q.push(cur->right);
    }
  }
}
```



最短路径问题：

Dijkstra解决的是有权最短路径问题，BFS是无权最短路径

优化：

多源BFS，可以往队列里放多个初始结点，这样就是以多个结点开始BFS

总结：

BFS遍历的基础上记录每一层 -> 层序遍历 ->  层序遍历的基础上记录层数 -> 最短路径



> 层序遍历的一些变种题目：
>
> LeetCode 103. Binary Tree Zigzag Level Order Traversal 之字形层序遍历
> LeetCode 199. Binary Tree Right Side View 找每一层的最右结点
> LeetCode 515. Find Largest Value in Each Tree Row 计算每一层的最大值
> LeetCode 637. Average of Levels in Binary Tree 计算每一层的平均值
> 对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：
>
> LeetCode 542. 01 Matrix
> LeetCode 994. Rotting Oranges
> 还有一道在真正的图结构中求最短路径的问题：
>
> LeetCode 310. Minimum Height Trees




【LeetCode 752】

可以把它看作迷宫的遍历问题，题目所给的不能到达的状态就是障碍物

换个角度来看，其实就是找**无向图的最短路径**，每个状态四个位能上下拨动，相当于八条边

<img src="../../../../学习/笔记合集/img/image-20210625083647396.png" alt="image-20210625083647396" style="zoom:33%;" />

```c++
class Solution {
public:
    int openLock(vector<string>& deadends, string target) {
      string start = "0000";
      unordered_set<string> deadendsSet(deadends.begin(), deadends.end());
      unordered_set<string> visted({start});
      queue<string> q({start});
      int res = 0;
      
      if (deadendsSet.count(start)) return -1;
      if (target == start) return 0;
      
      while (!q.empty()) {
        res++;
        int n = q.size();
        for (int i = 0; i < n; i++) { //每一层序遍历，相当于进行了一次拨动
          string cur = q.front(); q.pop();
          for (int j = 0; j < 4; j++) { //有四个数字可以变动
            for (int k = -1; k <= 1; k+=2) { //数字可以+1或者-1
              string newLock = cur;
            	newLock[j] = (newLock[j] - '0' + k + 10) % 10 +'0';  // 这里+10再取余是为了满足0-1=9 9+1=0
              if (!deadendsSet.count(newLock) && !visited.count(newLock)) q.push(newLock);
              visited.insert(newLock); //这里不用if，因为自动去重
            }
          }
        }
      }
      return -1;
    }
};
```



【LeetCode 773】

这道题的关键在于怎么样处理找到当前结点的边，比较好的解决办法是：先把二维数组压缩为字符串，因为这个图比较小，对于0来说，只有6个可能的位置，因此构造一个dirs数组，对于每个一维数组，表示可以去到的位置。假如0在第0位，那么可以向右到1号，或者向下到3号

更通用的做法是：构造上下左右数组，找到0以后计算0的新位置，然后将他俩进行swap即可，不过这种就不能压缩为字符串来做



【LeetCode815】据说是阿里的暑期实习机试题

还没看这个https://leetcode-cn.com/problems/bus-routes/solution/python-bfs-ba-gong-jiao-kan-zuo-zheng-ti-8w0i/







#### 回溯 - 适合用于搜索一个问题<u>所有的解</u>

回溯在发现某个方式不可能是结果的时候，退回上一步尝试其他可能

[LeetCode讲解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)

回溯和DFS的思想类似，不撞南墙不回头

区别是：DFS是遍历树或者图，甚至森林的方法，而回溯是遍历问题空间来找解决方案的办法，比起DFS更为通用

> DFS，递归，栈 都是后进先出

回溯 vs dp：

- dp只要求求出最优解，但不关心最优解对应的具体解（比如说dp[i] = max(dp[i-1], dp[i-2]) 只知道最优解是dp[i]，但不要求过程）；适合用于评估一个方案的效果
- 回溯可以搜索到所有的方案，本质是一个遍历算法
- dp需要存储子问题的解，回溯不需要
- 回溯可以用所有穷举法可以解决的问题，dp只用于最优子结构的问题

回溯常用模版：

```c++
res = []
path = []

def backtrack(未探索区域, res, path):
    if 未探索区域满足结束条件:
        res.add(path) # 深度拷贝
        return
    for 选择 in 未探索区域当前可能的选择:
        if 当前选择符合要求:
            path.add(当前选择)
            backtrack(新的未探索区域, res, path)
            path.pop() //我们从始至终只用了一个变量 path，所以当对 path 增加一个选择并 backtrack 之后，需要清除当前的选														择，防止影响其他路径的搜索

```

相关题目：【LeetCode131】

本题需要我们把字符串分成一系列的回文子串，按照模板，我们的思路应该是这样的：

未探索区域：剩余的未搜索的字符串 s；
结束条件：s 为空；
未探索区域当前可能的选择：每次选择可以选取 s 的 1 ~ length 个字符，cur = s[0...i]cur=s[0...i]；
当前选择符合要求：cur 是回文字符串 isPalindrome(cur)；
新的未探索区域：s 去除掉 cur 的剩余字符串，s[i + 1...N]s[i+1...N]。

【LeetCode78，LeetCode90】



【剑指Offer 38】

这道题目是要获得字符串中字符的全排列

按照正常的思考逻辑，假如没有重复字符，那就是n * (n-1)* .... 1种可能，直接BFS即可

但现在有重复字符，需要



#### 买股票问题：

只允许一次交易：遍历更新最小值，并取最大收益即可

不限制交易次数：遍历，只要能产生收益就加进来，返回累加和（一天内可以买或者卖）

限制交易次数：

```c++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        vector<int> sell(k+1,0);
        vector<int> buy(k+1,INT_MIN);
        for(int price : prices)
        {
            for(int i = 1;i <= k; i++) {
                buy[i] = max(buy[i],sell[i-1] - price);
                sell[i] = max(sell[i],buy[i] + price);
            }
        }
        return sell[k];
    }
};
```

注：内层循环以k=2比较好理解：

b1 = max(b1, -p);
s1 = max(s1, b1 + p);
b2 = max(b2, s1 - p);
s2 = max(s2, b2 + p);

这里的s1相当于sell[i-1]，b2相当于buy[i]，用自然语言解释就是(b2)是取b2和(前一次交易卖的利润-当前price)的最大值，s2就是取sell2和上一次买的股票加上以当前价格卖出的最大值

参考：https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1).

限制最大交易次数：

直接令最大交易次数`k = min(k, n/2)`即可 



-

#### 滑动窗口问题

```python
def findSubArray(nums):
    N = len(nums) # 数组/字符串长度
    left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
    sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
    while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
        sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
        while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
            sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
        # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1) # 需要更新结果
        right += 1 # 移动右指针，去探索新的区间
    return res
```

注意：内循环和外循环都是：先更新sum/res，再更新指针

> 以右指针作为驱动，拖着左指针向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

ps：记录一下，https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/，没有看懂

![image-20210205194837544](../../../../学习/笔记合集/img/image-20210205194837544.png)

我的一点心得：

曾经把几道题误判为用滑动窗口来做，但最后发现都不可以用。区别好像在于滑动窗口移动窗口的过程中一般不会让l右移到和r重合的，而这几道题目似乎都有可能有这种情况。

比如LeetCode525，LeetCode523

例：LeetCode424

> 给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。
>
> 注意：字符串长度 和 k 不会超过 104。
>
> ```
> 输入：s = "ABAB", k = 2
> 输出：4
> 解释：用两个'A'替换为两个'B',反之亦然。
> ```

```c++
class Solution {
public:
    static bool cmp(pair<char, int> p1, pair<char, int> p2) {
        return p1.second < p2.second;
    }

    int characterReplacement(string s, int k) {
        int l = 0, r = 0, n = s.size();
        int res = 0, maxCnt = 0;
        int counts[26];
        memset(counts, 0, sizeof(counts));
        while (r < n) {
            counts[s[r] - 'A']++;
            // maxCnt = max_element(m.begin(), m.end(), cmp)->second;
            maxCnt = max(maxCnt, counts[s[r] - 'A']);
            while (r - l + 1 - maxCnt > k) {
                counts[s[l] - 'A']--;
                l++;
            }
            res = max(res, r - l + 1);
            r++;
        }
        return res;
    }
};
```



例：LeetCode 1004

关键是做题意的转换

**最多可以把 K 个 0 变成 1，求仅包含 1 的最长子数组的长度**  -> 找一个包含K个0的最长子数组



滑动窗口题目简单版本：

某些简单题目，比如最大连续1的个数，这种不需要用双指针，将l记录非0数字，r向右移动即可



一些变式：

【LeetCode 220】

滑动窗口来保存所有下标满足条件的元素

比较特殊的点是需要用一个有序的数据结构来保存，可以选set、multiset、map

由于有有序性，因此可以用lower_bound查看是否存在这样的元素，只要存在，那肯定符合题意

```c++
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
      int n = nums.size();
      int l = 0, r = 0;
      map<long long, int> m;
      while (r < n) {
        if (r - l > k) {
          m.erase(nums[l++]);
        }
        auto it = m.lower_bound((long long)nums[r] - t);
        if (it != m.end() && abs(it->first - nums[r]) <= t) return true;
        m[nums[r]] = r;
        r++;
      }
      return false;
    }
};
```





#### 盛雨水问题

LeetCode 11 

`res = max(res, 短板 * 板子之间距离)`

需要注意的就是移动左指针，还是右指针

因为板子之间距离必然减小，所以只有移动短板才可能变大，移动长板的话，那结果肯定小于等于原来的res

https://leetcode-cn.com/problems/volume-of-histogram-lcci/solution/fu-xue-ming-zhu-mian-xiang-lie-de-ji-sua-6uqr/



#### 双指针问题

【LeetCode 26 80】

此类问题的关键是明确指针的含义。

以80为例，slow表示是即将放置元素的位置，fast是向后遍历的元素。

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 2, n = nums.size();
        if (n <= 2) return n;
        for (int fast = 2; fast < n; fast++) {
            if (nums[slow-2] != nums[fast]) {
                nums[slow++] = nums[fast];
            }
        }
        return slow;
    }
};
```







#### 位运算

&和&&区别：

&&和||的两边只能是bool类型

&和|既可以逻辑运算，也可以位运算；也就是说对bool类型直接逻辑运算，对int整型做按位与



【重要】

- 判断mask第i位是否为0的方法：

  ```c++
  if (mask & (1 << i))
  ```

- 判断mask最低位是否为0的方法：

  ```c++
  if (mask & 1 == 0)
  ```

- 让mask第i位赋值为1的方法：

  ```c++
  mask |= (1 << i)
  ```

- 判断数字n是否为2的幂：【LeetCode231】

  特点：2的幂

  - 去除最低位1的方法：

    - n & (n-1)，假如结果为0，那么正整数n为2的幂

      证明： n是100000 n-1就是011111，与运算后所有的位都变为0

  - 获取最低位的1:

    - n & (-n)，如果结果为n，那么正整数n为2的幂





相关题目：

【LeetCode190】

【LeetCode 78】

这个题目也就是相当于求出 0 ～ 111111的全排列

左移几位就是往后面补几个0

```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
      vector<vector<int>> res;
      vector<int> vec;
      int n = nums.size();
      
      for (int mask = 0; mask < (1 << n); mask++) { // mask < 1000
        vec.clear();
        for (int i = 0; i < n; i++) {
          // 判断第i位是否为1
          if (mask & (1 << i)) vec.push_back(nums[i]); // mask=111 i=2 -> 111 & 100
        }
        res.push_back(vec);
      }
      
      return res;
    }
};
```



【LeetCode191】

计算某个数字的二进制表示有多少个1

- 普通方法：

```c++
int num = 2, cnt = 0;
while (num > 0) { //num等于0已经要结束了
  cnt += num & 1;  //这个是判断最低位是否为1
  num >>= 1;
}
```

- 特殊方法：

假如要求一连串的，比如0到n的数字各有多少；有两种方法：

【LeetCode 338】

```c++
int num = 10;
vector<int> ans(num+1);
for (int i = 0; i <= num; i++) {
  if (i % 2 == 0) ans[i] = ans[i/2]; //比如2和4，4只是2在低位补0，总1不变
  else ans[i] = ans[i-1] + 1; //奇数的话等于离它最近的偶数+1
}
```

另一种特殊思路

> ```
> i    binary '1'  i&(i-1)
> 0    0000    0
> -----------------------
> 1    0001    1    0000
> -----------------------
> 2    0010    1    0000
> 3    0011    2    0010
> -----------------------
> 4    0100    1    0000
> 5    0101    2    0100
> 6    0110    2    0100
> 7    0111    3    0110
> -----------------------
> 8    1000    1    0000
> 9    1001    2    1000
> 10   1010    2    1000
> 11   1011    3    1010
> 12   1100    2    1000
> 13   1101    3    1100
> 14   1110    3    1100
> 15   1111    4    1110
> ```

二进制中1的个数也就是 i & (i-1)中的数+1，这样就形成了递推式

```c++
res[i] = res[i & (i-1) + 1]
```

TODO 

【LeetCode 137】



【LeetCode477】

本题目的要求是计算所有数字两两组合的汉明距离，暴力法会TL。

正确的做法：统计在第i位为1的有tmp个数字，那么第i位为0的有n-tmp个，因此在这一位产生的汉明距离就是 tmp * (n - tmp)个

解释就是会在这tmp与(n-tmp)做汉明距离的时候会产生不同

【LeetCode 421】

核心是从高位到低位一位位的进行遍历，判断每一位是否可能为1 

具体来讲，res是从10000一直遍历，判断11000是否可能，11100是否可能等等，以此类推

```c++
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size(), res = 0, mask = 0;
        for (int i = 30; i >= 0; i--) {
           //不断取出前缀，就是从第i位到最低位。最高位到i位是已经确定的部分
            mask |= (1 << i); 
            unordered_set<int> s;
            for (int num : nums) {
                s.insert(num & mask);
            }
         
          	// 当前res和第i位结果取或运算，就是目标结果t，比如当前res是10000，t就是11000，然后依次遍历。 因为题目要求是两个前缀的结果，利用异或的性质，如果前缀和目标的结果仍然还在s里，说明此位为1能取到
            int t = res | (1 << i);
            for (int prefix : s) {
                if (s.count(t ^ prefix)) {
                    res = t;
                    break;
                }
            }
        }
        return res;
    }
};
```



【LeetCode 1442】

本道题的核心还是运用了异或的特性 a ^ b = c 那么 c ^ a = b

通过转化，可以将题目要求转化为 $$xorSum[i] = xorSum[k+1]$$

<u>这里需要注意的是异或前缀和数组，题解是构建了一个长度为n+1的数组，下标从0开始</u>（如果取长度为n的话，要求的就$$xorSum[i-1] = xorSum[k]$$ ，这样不太好确定二重遍历的下标）

```c++
class Solution {
public:
    int countTriplets(vector<int>& arr) {
        int n = arr.size(), res = 0;
        vector<int> xorSum(n+1);
        xorSum[0] = 0;
        for (int i = 0; i < n; i++) {
            xorSum[i+1] = xorSum[i] ^ arr[i];
        }

        // s[j]^ s[i] = s[k+1] ^ s[j]
        for (int i = 0; i < n; i++) {
            for (int k = i + 1; k < n; k++) {
                if (xorSum[i] == xorSum[k+1]) {
                    // i+1 到 k的所有j都满足题意
                    res += k - i;
                }
            }
        }
        return res;
    }
};
```

比较特殊的题目：

【LeetCode1239】



#### 前缀和问题

应用场景：除一般的需要计算子数组和的情况外，一般子数组问题都可以思考是否能用前缀和

##### 一维前缀和

```c++
for (int i = 1; i < n; i++) {
  preSum[i] = preSum[i-1] + nums[i];
}
```



##### 二维前缀和



理解：

<img src="../../../../学习/笔记合集/img/image-20210302102731472.png" alt="image-20210302102731472" style="zoom:33%;" />

> S(O,D) = S(O,C) + S(O,B)-S(O,A)

```c++
vector<vector<int>> preSum;
preSum.resize(row+1, vector<int>(column+1, 0)); //这里设置比原有的矩阵多一行一列，是为了让(0,0)也可求

//预处理求前缀和
for (int i = 0; i < row; i++) {
  for (int j = 0; j < column; j++) {
    preSum[i+1][j+1] = preSum[i][j+1] + preSum[i+1][j] - preSum[i][j] + matrix[i][j];
  }
}
```

<img src="../../../../学习/笔记合集/img/image-20210302103755376.png" alt="image-20210302103755376" style="zoom:33%;" />

> S(A,D) = S(O,D) - S(O,E) - S(O,F) + S(O,G)

```c++
// 求(row1, column1)到(row2, column2)的和
return preSum[r2+1][c2+1] - preSum[r2+1][c1] - preSum[r1][c2+1] + preSum[r1][c1]
```

补充：这里因为用了辅助行，(r2,c2)对应的是(r2+1,c2+1)



下面的两道题比较类似，都利用了前缀和，并且借助哈希表，找出当前前缀和与之前前缀和之间的关系，最后求出结果。

然后具体实现上有一个比较重要的**易错点**，那就是哈希表需要留出第一个位置，作为一个哨兵节点，它的主要作用是在求后面的前缀和的时候，可能需要利用到该位置以前的全部元素，因此多加入一个元素就可以实现这个效果。

【LeetCode 525】

```c++
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int res = 0, n = nums.size(), sum = 0;
        unordered_map<int, int> m({{0,-1}}); // key是01序列和，value是这个序列的结束下标
        for (int i = 0; i < n; i++) {
            sum += (nums[i] == 0) ? -1 : 1; //等价于sum += (nums[i] << 1) -1;
            if (m.find(sum) != m.end()) res = max(res, i - m[sum]); //前缀和如果相同，说明之间的子数组0和1数量相同
            else m[sum] = i; //只有找不到对应的sum才进行更新，因为要找最大值，所以map里的value越小越好
        }
        return res;
    }
};
```

【LeetCode 523】

补充：同余定理，假如 $$\frac{sum[j]}{k} - \frac{sum[i-1]}{k} = n$$，因为如果让两个商相减为整数，那么$$sum[j]$$和$$sum[i-1]$$取余相同

```c++
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> preSum(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            preSum[i] = preSum[i-1] + nums[i-1];
        }

        // 前缀和满足余数相同.   sum[i] - sum[j] = n * k
        unordered_set<int> st;
        for (int i = 2; i <= n; i++) {
            int cur = preSum[i-2] % k; //通过i-2来保证取到的子数组至少两个元素
            st.insert(cur);
            if (st.find(preSum[i] % k) != st.end()) return true;
        }
        return false;
    }
};
```







#### 单调栈问题 - 处理前后<u>元素之间的大小关系</u>

```c++
insert x;
while !st.empty() && st.top() < x :
	st.pop();
st.push(x);
```

s元素出栈的时机：不再单调

单调栈的性质：

- 单调栈中的元素具有单调性
- 递增（减）栈可以找到元素左右两侧第一个比自己小（大）的元素

【LeetCode 503】

题目的要求是找到数组中每个数字的下一个最大的元素；暴搜的话，如果处理类似[6,5,4,3,9]这种数组的时候，数组中递减的部分的下一个最大的元素相同，可以一并返回

```c++
vector<int> nextGreaterElements(vector<int>& nums) {
  int n = nums.size();
  vector<int> res(n, -1);
  stack<int> st;
  for (int i = 0; i < n * 2; i++) {
    int num = nums[i % n];
    while (!st.empty() && nums[st.top()] < num) {
      res[i % n] = num;
      st.pop();
    }
  }
  return res;
}
```

【LeetCode 456】

132模式（贪心的解读：1尽可能小，2尽可能大）

暴力解法 ：

$$O(N^2)$$ 有点贪心的思想，遍历数组时候，以132模式中的3为关注点，左边维护一个3左边数组的最小值，右边通过暴力搜索一个比3小，比1大的一个数字

单调栈：

问题的突破口是132模式中的2，也就是第三个数字，因为第一个数字是找最小，中间是最大，第三个数字的限制比较多。

其实2就是要**<u>找到比3小的最大元素</u>**，因此建立一个单调栈比较合适

因此从后往前遍历，建立一个递减栈，并且栈中的数字都是大于第三个数字的，一直从后往前遍历，如果碰到破坏栈中元素顺序，那么把里面的元素pop出来，最后一个被pop出来的元素，就是比3小的最大元素，然后把它赋值给2。

同时遍历的过程中，如果发现如果nums[i] < third，那么这说明找到了那个最小元素，也就是1。（也可以提前计算好



举例：

[2, 4, 2, 3, 5]

从后往前遍历，栈中的元素从底向上是 5 3 2，遇到4后，弹出2，3，3就是比模式132中3小的最大元素，那么将“2”赋值为3，停止while，然后往栈里压入4，再往前遍历，2小于3，那么[2,4,3]符合题意

```c++
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int third = INT_MIN;
        stack<int> st; //递减栈，栈中的元素均大于third
        for (int i = nums.size()-1; i >= 0; i--) {
            if (nums[i] < third) return true;
            while (!st.empty() && st.top() < nums[i]) {
                third = st.top(); st.pop();
            }
            st.push(nums[i]);
        }
        return false;
    }
};
```



[参考](https://jjaychen.me/programming/monotone-stack)

两种题型：

- 单向查找
- 双向查找

相关题目：





#### LIS问题

##### 动态规划：$$O(N^2)$$

dp[i]表示以i结尾的最长递增子序列长度，递推式是`dp[i] = max(dp[i], dp[j]+1)`

```c++
int lengthOfLIS(vector<int>& nums) {
  int res = 0, n = nums.size();
  vector<int> dp(n, 1);
  for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
      if (nums[i] > nums[j]) {
        dp[i] = max(dp[i], dp[j]+1);
      }
    }
    res = max(res, dp[i]);
  }
}
```

##### 贪心 + 二分： $$O(NlgN)$$

https://blog.csdn.net/u012505432/article/details/52228945



##### 二维LIS问题

【LeetCode 354】



#### 表达式问题（遇到括号想栈和递归）

总结：

##### 总结：**括号类问题的处理方法就是栈或者递归**

无括号：遇到乘除立即算，遇到加减先入栈（遇到乘除，栈顶元素和当前元素进行运算，而如果是加减，把数字入栈或者取反后入栈）

注意：C++和Java的地板除法是向零取整 eg: -3 / 2 = -1

##### 类型1：加减法，括号

没有运算优先级的比较

遇到左括号的时候，把当前结果和左括号前的符号压入栈，然后把括号里的式子当成一个完整的式子来计算，遇到右括号的时候，给括号内的运算结果加上符号，然后加上栈里弹出来的值

```c++
stack<int> st;
int res = 0, sign = 1;
for (int i = 0; i < s.size(); i++) {
  char chr = s[i];
  switch(chr) {
    case '+':
      sign = 1;
    	break;
    case '-':
      sign = -1;
      break;
    case '(':
      st.push(res);
      st.push(sign);
      res = 0;
      sign = 1;
      break;
    case ')':
      res *= st.top(); st.pop();
      res += st.top(); st.pop();
      break;
    case ' ':
      break;
    default:
      int num = 0;
      while (i < n && chr >= '0') {
        num = num * 10 + chr - '0';
        i++;
      }
      res += sign * num;
      i--;
  }
  return res;
}
```

另一种思路，直接把括号内的部分当成一个式子来算，也就是用递归

```c++
class Solution {
public:
    int calculate(string s) {
        int res = 0, num = 0, sign = 1, n = s.size();
        for (int i = 0; i < n; ++i) {
            char c = s[i];
            if (c >= '0' && c <= '9') {
                num = 10 * num + (c - '0');
            } else if (c == '(') {
                int j = i, cnt = 0;
              	for (; i < n; i++) {
                  if (s[i] == '(') cnt++;
                  if (s[i] == ')') cnt --;
                  if (cnt == 0) break;
                }
              num = calculate(s.substr(j+1, i-j+1));
            }
            if (c == '+' || c == '-' || i == n - 1) {
                res += sign * num;
                num = 0;
                sign = (c == '+') ? 1 : -1;
             } 
        }
        return res;
    }
};
```

##### 类型二：加减乘除【LeetCode227】





##### 类型三：加减乘除括号【LeetCode772】



【LeetCode 726】比较庞大的模拟题，没有亲手写，看看思路

这个的解法写的很好 https://github.com/grandyang/leetcode/issues/726







#### 空间有限制的处理方法

不借用辅助的数据结构，一般是用参数所提供的数据结构来进行

有一个原地算法，

想到的几种处理思路：

- 借助int是32位，可以用位运算

- 借助参数数组，比如可以用矩阵的第一行第一列作为存储，再用常数变量存储第一行第一列

  - 【LeetCode 73】

    空间复杂度：O(M+N) 我的一般思路是用两个数组，维护有哪些行和列有0，然后再遍历一遍matrix置0

    空间复杂度：O(1) 用两个变量记录第一行和第一列是否有0，然后再用第一行第一列记录其他行和列的情况

- 通过多次swap

  - 将一个数组逆序，就可以不断做交换而达成目标

  ```c++
  for (int i = 0; i < int(n / 2); i++) {
    swap(array[i], array[n-i-1]);
  }
  ```

  

#### 数字类型题

丑数：只包含质因数 `2`、`3` 和/或 `5` 的正整数。

【LeetCode 264】

可以用三指针做法，注意规律就是后面的丑数就是前面的丑数再乘2/3/5

因此每次将三者的最小值加入结果集合即可

Ps: 另外一种方法是用优先队列自然排序，不过每次遍历的时候需要先判断是否队列头有重复元素（这个没懂）

https://www.cnblogs.com/grandyang/p/4743837.html



#### 排序类问题

类型1：组成最大数

【LeetCode 179】

```c++
sort(strs.begin(), strs.end(), [](string &a, string &b) {
  return a + b > b + a;
})
```

<u>注意点是最后需要判断是否首位为0</u>



#### 前缀树

【LeetCode 208】

三个性质：

根节点没有字符，除根节点外每个节点包含一个字符

根节点某个节点，字符连接起来就成为节点对应的字符串

每个节点的子节点包含的字符不同(兄弟之间不一样

)

```c++
class TrieNode {
public:
    vector<TrieNode*> children;
    TrieNode() : children(26) { //注意这里的初始化只能放在构造方法的列表里
        for (TrieNode* node : children) {
        	node = nullptr; //这里可能有空子节点，所以是nullptr
        }
    }
    bool isWord = false;
};

class Trie {
private:
    TrieNode* root;
public:
    /** Initialize your data structure here. */
    Trie() {
        root = new TrieNode(); //注意一下指针初始化的方式，这里是需要初始化实际的节点，所以用创建对象
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        TrieNode* p = root;
        for (char c : word) {
            int i = c - 'a';
            if (!p->children[i]) p->children[i] = new TrieNode();
            p = p->children[i];
        }
        p->isWord = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        TrieNode* p = root;
        for (char c : word) {
            int i = c - 'a';
            if (!p->children[i]) return false;
            p = p->children[i];
        }
        return p->isWord;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        TrieNode* p = root;
        for (char c : prefix) {
            int i = c - 'a';
            if (!p->children[i]) return false;
            p = p->children[i];
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */
```

实际应用：自动补全单词，比如输入法

TODO: LeetCode 1707



#### 罗马数字和十进制的相互转化

【LeetCode13】罗马->整数

我的处理方法是一次取两个，比如AB，如果AB在map，那么加上对应数字，如果不是，那就i++继续遍历

```c++
class Solution {
public:
    int romanToInt(string s) {
        int res = 0, n = s.size();
        unordered_map<char, int> m= {
            {'M', 1000},
            {'D', 500},
            {'C', 100},
            {'L', 50},
            {'X', 10},
            {'V', 5},
            {'I', 1},
        };

        for (int i = 0; i < n; i++) {
            int cur = m[s[i]];
            if (i < n-1 && cur < m[s[i+1]]) {
                res -= cur;
            } else {
                res += cur;
            }
        }
        return res;
    }
};
```

【LeetCode12】整数->罗马

构造一个递减map，包含所有可能出现的罗马数字单元，依次遍历，找到不大于当前整数的最大罗马数字，加到结果里

```c++
#include<algorithm>
class Solution {
public:
    static bool cmp(pair<int, string> p1, pair<int, string> p2) {
        return p2.first < p1.first;
    }

    string intToRoman(int num) {
        string res = "";
        vector<pair<int, string>> m= {
            {1000, "M"},
            {900, "CM"},
            {500, "D"},
            {400, "CD"},
            {100, "C"},
            {90, "XC"},
            {50, "L"},
            {40, "XL"},
            {10, "X"},
            {9, "IX"},
            {5, "V"},
            {4, "IV"},
            {1, "I"}
        };

        for (auto [number , roman] : m) {
            while (num >= number) {
                res += roman;
                num -= number;
            }
        }
        return res;
    }
};
```





#### 位运算

【LeetCode 421】

核心是从高位到低位一位位的进行遍历，判断每一位是否可能为1 

具体来讲，res是从10000一直遍历，判断11000是否可能，11100是否可能等等，以此类推

```c++
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size(), res = 0, mask = 0;
        for (int i = 30; i >= 0; i--) {
           //不断取出前缀，就是从第i位到最低位。最高位到i位是已经确定的部分
            mask |= (1 << i); 
            unordered_set<int> s;
            for (int num : nums) {
                s.insert(num & mask);
            }
         
          	// 当前res和第i位结果取或运算，就是目标结果t，比如当前res是10000，t就是11000，然后依次遍历。 因为题目要求是两个前缀的结果，利用异或的性质，如果前缀和目标的结果仍然还在s里，说明此位为1能取到
            int t = res | (1 << i);
            for (int prefix : s) {
                if (s.count(t ^ prefix)) {
                    res = t;
                    break;
                }
            }
        }
        return res;
    }
};
```



【LeetCode 1442】

本道题的核心还是运用了异或的特性 a ^ b = c 那么 c ^ a = b

通过转化，可以将题目要求转化为 $$xorSum[i] = xorSum[k+1]$$

<u>这里需要注意的是异或前缀和数组，题解是构建了一个长度为n+1的数组，下标从0开始</u>（如果取长度为n的话，要求的就$$xorSum[i-1] = xorSum[k]$$ ，这样不太好确定二重遍历的下标）

```c++
class Solution {
public:
    int countTriplets(vector<int>& arr) {
        int n = arr.size(), res = 0;
        vector<int> xorSum(n+1);
        xorSum[0] = 0;
        for (int i = 0; i < n; i++) {
            xorSum[i+1] = xorSum[i] ^ arr[i];
        }

        // s[j]^ s[i] = s[k+1] ^ s[j]
        for (int i = 0; i < n; i++) {
            for (int k = i + 1; k < n; k++) {
                if (xorSum[i] == xorSum[k+1]) {
                    // i+1 到 k的所有j都满足题意
                    res += k - i;
                }
            }
        }
        return res;
    }
};
```



优化思路：

[参考](https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solution/xing-cheng-liang-ge-yi-huo-xiang-deng-sh-jud0/)

因为最后要求的是(k-i1) + (k-i2) ..... (k-im) = mk - (i1 + i2 .... im)

所以把i 的出现次数m和i的和存下来即可

```c++
class Solution {
public:
    int countTriplets(vector<int> &arr) {
        int n = arr.size();
        vector<int> s(n + 1);
        for (int i = 0; i < n; ++i) {
            s[i + 1] = s[i] ^ arr[i];
        }
        unordered_map<int, int> cnt, total; //cnt表示出现次数，total表示下标和
        int ans = 0;
        for (int k = 0; k < n; ++k) {
            if (cnt.count(s[k + 1])) {
                ans += cnt[s[k + 1]] * k - total[s[k + 1]];
            }
            ++cnt[s[k]];
            total[s[k]] += k;
        }
        return ans;
    }
};

```





#### 括号匹配类题目

【LeetCode1190】

我的思路是找出所有括号的位置，然后依次往外进行反转

题解的思路是用栈，处理括号类问题一般都会用到栈

一个字符串分为三部分，分别进行处理 `a(bc)d`

遇到左括号，把a放入栈

遇到右括号，把里面的内容反转，处理后的字符串是栈的顶端加上反转后的字符串，最后再加上括号右边的内容

```c++
class Solution {
public:
    string reverseParentheses(string s) {
        string str;
        stack<string> st;
        for (char & c : s) {
            if (c == '(') {
                st.push(str); 
                str = "";
            } else if (c == ')') {
                reverse(str.begin(), str.end());
                str = st.top() + str;
                st.pop();
            } else {
                str.push_back(c);
            }
        }
        return str;
    }
};
```



#### 进制转换类

【LeetCode 168】

这道题相当于十进制和26进制的转换

```c++
class Solution {
public:
    string convertToTitle(int columnNumber) {
        string res;
        while (columnNumber--) { //这里递减就是因为把字母区间转化到[0,25]区间中
            res += columnNumber % 26 + 'A';
            columnNumber /= 26;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

注意：这里的`columnNumber--`非常巧妙，同时也解决了当columnNumber%26等于0的时候应该取Z而不是@的情况

$$A@Y: 701 = 1 \times 26 ^ 2+ 0 \times 26 ^1 + 25 \times 26 ^ 0$$

$$ZY: 701 = 26 \times 26 ^1 + 25 \times 26 ^ 0$$











#### 桶排序

【LeetCode 451】













