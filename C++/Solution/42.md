# TODO
用暴搜的方法会Time Limt Exceed，不知道有没有解决的办法
其他的方法如下
### solution1 求最小最大
类似于dp

### solution2 dp
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() < 3) {
            return 0;
        }
        int len = height.size();
        vector<int> left_max, right_max;
        
        left_max.push_back(height[0]);
        for (int i = 1; i < height.size(); i++) {
            left_max.push_back(max(left_max[i-1], height[i]));
        }
        
        right_max.push_back(height[len-1]);
        for (int i = 1; i < height.size(); i++) {
            right_max.push_back(max(right_max[i-1], height[len-1-i]));
        }
        reverse(right_max.begin(), right_max.end());   
        
        int res = 0;
        for (int i = 0; i < len - 1; i++) {
            res += min(right_max[i], left_max[i]) - height[i];
        }
        return res;
        
    }  
};
```
### solution3 stack  TODO

```c++
int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];
            ans += distance * bounded_height;
        }
        st.push(current++);
    }
    return ans;
}
```

### solution4 two pointer
```c++
class Solution {
    public int trap(int[] height) {
        // time : O(n)
        // space : O(1)
        if (height.length==0) return 0; 
        int left = 0, right = height.length-1; 
        int leftMax=0, rightMax=0; 
        int ans = 0; 
        while (left < right) {
            if (height[left] > leftMax) leftMax = height[left]; 
            if (height[right] > rightMax) rightMax = height[right];
            if (leftMax < rightMax) {
                ans += Math.max(0, leftMax-height[left]); 
                left++; 
            } else {
                ans += Math.max(0, rightMax-height[right]); 
                right--; 
            }
        }
        return ans; 
    }
}
```