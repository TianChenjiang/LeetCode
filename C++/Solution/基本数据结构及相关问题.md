### 链表类

特点：每个节点有一个值，和一个指向下一个节点的指针

特点决定了 <u>很多链表类问题用**递归**来解决</u>

不能直接获取任意节点值，也不能直接获得总长度



基本表示：

```c++
struct ListNode {
  int val;
  ListNode* next;
  ListNode(int x) : val(x), next(nullptr) {}
}
```



处理链表类问题经常会因为对当前节点进行操作而导致内存或 指针出现问题，解决方法：

- 尽量处理当前节点的下一个节点，而非节点本身
- 建立一个虚拟节点 dummy node，指向当前链表的头节点，即使所有节点都被删除，还保留dummy node，最后返回dummy->next即可

```c++
ListNode* dummy = new ListNode(-1, head); //如果头节点被删除的话，那不能用head了，但dummy还保留，直接返回dummy->next即可
ListNode* cur = dummy; //用于遍历
```



##### 删除链表元素【LeetCode203】

无需遍历到最后一个元素，只需要从dummy遍历到倒数第二个元素即可（因为删除必须借助前一个结点）

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
      ListNode* dummy = new ListNode(-1,head);
      ListNode* cur = dummy;
      while (cur->next) { //注意这里必须是用cur遍历，因为可能链表首元素是目标元素，然后while的结束条件是cur->next为空
        if (cur->next->val == val) cur->next = cur->next->next;
        else cur = cur->next; //只有没有删除元素才移动cur
      }
      return dummy->next;
    }
};
```



##### 翻转链表

递归法：

```c++

```

非递归法：

```c++

```

##### 翻转部分链表

```c++

```

##### 删除重复节点【LeetCode82】

这道题的关键在于需要去掉所有出现重复元素，而且可能不止一次出现

```c++
ListNode* dummy = new ListNode(-1, head);
ListNode* cur = dummy;
while (cur->next && cur->next->next) { //比如1->2->2->3 最后需要1 3 相连，因此比较的是这两者
  if (cur->next->val == cur->next->next->val) {
    int x = cur->next->val;
    while (cur->next && cur->next->val == x) { //当cur->next不为x或者为null时候停止,因为可能重复多次，所以用个while
      cur->next = cur->next->next;
    }
  } else cur = cur->next;
}
return dummy->next;
```

##### 链表倒数第k个节点 【剑指offer22】

```c++
ListNode* getKthFromEnd(ListNode* head, int k) {
  ListNode* former = head, *latter = head;
  for (int i = 0; i < k; i++) former = former->next;
  while (former) {
    latter = latter->next;
    former = former->next;
  }
  return latter;
}
```

##### 获取相交链表的相交点

易错点：在遍历链表的时候，while的判断条件应该是curA是否为空，而不是curA->next是否为空，如果是后者的话遍历不到最后一个节点

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> st;
        ListNode* curA = headA, *curB = headB;
        while (curA != NULL) {
            st.insert(curA);
            curA = curA->next;
        }
        while (curB != NULL) {
            if (st.find(curB) != st.end()) return curB;
            curB = curB->next;
        }
        return NULL;
    }
};
```







### 哈希

##### 手动实现hashset/hashmap

```c++
class myHashSet {
private:
  vector<list<int>> vec;
public:
  const int staitc base = 769; //质数
  static int hash(int key) {
    return key % base;
  }
  myHashSet() : vec(base);
  
  void add(int key) {
        int hashKey = hash(key);
        for (auto it = vec[hashKey].begin(); it != vec[hashKey].end(); it++) {
            if (*it == key) return;
        }
        vec[hashKey].push_back(key);
    }
    
    void remove(int key) {
        int hashKey = hash(key);
        for (auto it = vec[hashKey].begin(); it != vec[hashKey].end(); it++) {
            if (*it == key) {
                vec[hashKey].erase(it); 
                return;
            }
        }
    }
    
    /** Returns true if this set contains the specified element */
    bool contains(int key) {
        int hashKey = hash(key);
        for (auto it = vec[hashKey].begin(); it != vec[hashKey].end(); it++) {
            if (*it == key) return true;
        }
        return false;
    }
}
```



### 迭代器

【LeetCode 341】 扁平化迭代器

两种思路：

- 递归：其实也就是dfs的方法，不过迭代器的思想不应该是递归解决；递归也就是在构造函数中就展开，迭代器应该是边访问边进行展开

- 迭代

  具体思路：

  用栈来解决，首先将这个内嵌列表逆序放入栈内，原因是栈是先进后出，所以需要逆序

  然后在每次调用`hasNext`的时候用栈进行展开

  





### 二叉树

#### 遍历

以inorder为例：

##### 递归版

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
      vector<int> res;
      helper(root, res);
      return res;
    }
  
  	void helper(TreeNode* root, vector<int> &res) {
      if (!root) return;
      helper(root->left, res);
      res.push_back(root->val);
      helper(root->right, res);
    }
};
```

##### 非递归版

借用栈来实现递归

https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/

一路到底遍历所有左节点，保存在栈中，然后不断弹出栈顶元素，遍历它的右子树 

<img src="../../../../学习/笔记合集/img/image-20210328215156443.png" alt="image-20210328215156443" style="zoom:33%;" />

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
      vector<int> res;
      stack<TreeNode*> st;
      while (p || !st.empty()) {
        while (p) {
          st.push(p);
          p = p->left;
        }
        p = s.top(); s.pop();
        res.push_back(p->val);
        p = p->right;
      }
      return res;
    }
};
```

#### 遍历题目的变形

【938】获得二叉搜索树在某个范围和

我的思路是正常的递归遍历，然后遇到符合条件的值就累加。

题解的思路：

利用了搜索树自然排序的特点，如果当前值大于high，那它右边不可能还有符合条件的结点了，小于low同理

最后`root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high)`很关键

```c++
class Solution {
public:
    int rangeSumBST(TreeNode *root, int low, int high) {
        if (root == nullptr) {
            return 0;
        }
        if (root->val > high) {
            return rangeSumBST(root->left, low, high);
        }
        if (root->val < low) {
            return rangeSumBST(root->right, low, high);
        }
        return root->val + rangeSumBST(root->left, low, high) + rangeSumBST(root->right, low, high);
    }
};
```



### 多叉树

也同样可以用递归的方式完成前序等遍历，如【LeetCode 1600】

但需要注意的是需要思考怎样存储效果最好，比如这道题，比较适合用string为主键进行存储，那么用一个map<string,vectror<string>> 就可以完成对树的构造，而我在一开始使用的是存储结点对象，后面比如针对某个字符串的删除就会比较繁琐

另外一种思路是采用单向链表 https://leetcode-cn.com/problems/throne-inheritance/solution/gong-shui-san-xie-shi-yong-dan-xiang-lia-7t65/，思路比较类似，不过转为只记录next和最后一个儿子，因为插入儿子的时候需要插入最后一个儿子后面











