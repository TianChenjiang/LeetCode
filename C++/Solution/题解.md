## 1

一开始的疑惑是map中重复元素会被覆盖。后来发现没问题：每次遍历的时候，会拿着刚才那个未被覆盖的元素，然后在map里面去找匹配元素，因此被覆盖的那个元素没有受到影响



## 5

### 两个关键点

- 不能用惯性的思维S(i,j)，然后j就是0到j，这样不能保证前一个状态已经实现过，必须是用0-0 0-1 1-1 0-2 1-2 2-2 这种遍历顺序
- 对特殊状态的考虑 这道题对应的是`i = j`以及`i = j+1`



### 分析：

#### 暴搜

可以对字符串的长度的奇偶来分类进行考虑。

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.size() < 2) return s;
        int n = s.size(), maxLen = 0, start = 0;
        for (int i = 0; i < n - 1; ++i) {
            searchPalindrome(s, i, i, start, maxLen);
            searchPalindrome(s, i, i + 1, start, maxLen);
        }
        return s.substr(start, maxLen);
    }
    void searchPalindrome(string s, int left, int right, int& start, int& maxLen) {
        while (left >= 0 && right < s.size() && s[left] == s[right]) {
            --left; ++right;
        }
        if (maxLen < right - left - 1) {
            start = left + 1;
            maxLen = right - left - 1;
        }
    }
};
```






#### DP

主要是写出状态转移方程，并且注意特殊边界的处理，还需要再加练习。





#### 马拉车算法







https://www.cnblogs.com/grandyang/p/4475985.html



## 10

https://blog.csdn.net/wangyaninglm/article/details/55827721



#### [](https://leetcode.com/problems/regular-expression-matching/discuss/5651/easy-dp-java-solution-with-detailed-explanation)



## 18

和3sum的思路一致，区别是在最外层加了for循环

踩的坑：

- 记得left right的赋值要放在while内部，因为要随之更新
- while (l < r && nums[l] == left) l++;类似这种的写法，因为第一次比较一定相等，因此没必要先提前l++
- while (i < nums.size()-3 && nums[i] == nums[i+1]) i++; 如果写成while (i < nums.size() && nums[i] == cur) i++;
      i-=1; 一定要记得i--; 因为最后是不等才跳出循环，但这个不等量有可能作为答案，如果直接等会在外层for直接跳过



## 20

判断是否是有效的括号匹配问题，#30是这道题的加强版。
有效满足两个条件：

- 开括号必须被闭括号关闭
- 开括号必须按照正确的顺序被闭括号关闭

遇到一个神奇的bug：`AddressSanitizer:DEADLYSIGNAL`，证明是由于越界产生的错误。这道题是对于类似")"这种用例，对它判断时栈内为空，因为无法stack.top()，所以会报这个错误。



## 32

是20题的加强版，是要求出最长的有效子串。

#### solution1:

用栈解决，注意要事先在栈中push一个-1，否则如果直接对空栈取top或者pop的话会造成越界。
遇到open brackets，将索引push到栈中；
遇到close brackets，pop后，如果栈为空，那么以这个闭括号的索引为开始，记录有效子串的新长度；
                         否则这部分是当前子串的一部分 长度为 i-stack.top()

#### solution2:

动态规划

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int res = 0, n = s.size();
        vector<int> dp(n + 1);
        for (int i = 1; i <= n; ++i) {
            int j = i - 2 - dp[i - 1];
            if (s[i - 1] == '(' || j < 0 || s[j] == ')') {
                dp[i] = 0;
            } else {
                dp[i] = dp[i - 1] + 2 + dp[j];
                res = max(res, dp[i]);
            }
        }
        return res;
    }
};
```

[参考解释](https://bangbingsyb.blogspot.com/2014/11/leetcode-longest-valid-parentheses.html)

#### solution3:

暴力解法



## 42 - todo

用暴搜的方法会Time Limt Exceed，不知道有没有解决的办法
其他的方法如下

### solution1 求最小最大

类似于dp

### solution2 dp

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() < 3) {
            return 0;
        }
        int len = height.size();
        vector<int> left_max, right_max;
        
        left_max.push_back(height[0]);
        for (int i = 1; i < height.size(); i++) {
            left_max.push_back(max(left_max[i-1], height[i]));
        }
        
        right_max.push_back(height[len-1]);
        for (int i = 1; i < height.size(); i++) {
            right_max.push_back(max(right_max[i-1], height[len-1-i]));
        }
        reverse(right_max.begin(), right_max.end());   
        
        int res = 0;
        for (int i = 0; i < len - 1; i++) {
            res += min(right_max[i], left_max[i]) - height[i];
        }
        return res;
        
    }  
};
```

### solution3 stack  TODO

```c++
int trap(vector<int>& height)
{
    int ans = 0, current = 0;
    stack<int> st;
    while (current < height.size()) {
        while (!st.empty() && height[current] > height[st.top()]) {
            int top = st.top();
            st.pop();
            if (st.empty())
                break;
            int distance = current - st.top() - 1;
            int bounded_height = min(height[current], height[st.top()]) - height[top];
            ans += distance * bounded_height;
        }
        st.push(current++);
    }
    return ans;
}
```

### solution4 two pointer

```c++
class Solution {
    public int trap(int[] height) {
        // time : O(n)
        // space : O(1)
        if (height.length==0) return 0; 
        int left = 0, right = height.length-1; 
        int leftMax=0, rightMax=0; 
        int ans = 0; 
        while (left < right) {
            if (height[left] > leftMax) leftMax = height[left]; 
            if (height[right] > rightMax) rightMax = height[right];
            if (leftMax < rightMax) {
                ans += Math.max(0, leftMax-height[left]); 
                left++; 
            } else {
                ans += Math.max(0, rightMax-height[right]); 
                right--; 
            }
        }
        return ans; 
    }
}
```





## 53

我用了dp的方法，有一个坑的地方就是可能整个数组全是负数。

Solution2:
在线处理，如果i号元素加起来比

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = INT_MIN, curSum = 0;
        for (int num : nums) {
            curSum = max(curSum + num, num);
            res = max(res, curSum);
        }
    }
};
```

我的改进版

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int dp[nums.size()+1];
        int max_num = *max_element(nums.begin(), nums.end());
        for (int i = 0; i < nums.size()+1; i++) {
            dp[i] = max_num;
        }
        int temp = 0;
        for (int i = 0; i < nums.size(); i++) {
            temp = max(nums[i], dp[i]+nums[i]);
            dp[i+1] = temp;
        }
        return *max_element(dp, dp+nums.size()+1);
    }
};
```

这种最大子列和的问题可以用在线处理或者分而治之的思想，用动态规划的话有点鸡肋



## 70

简单的DP
有个小疑惑是为什么dp[n] = dp[n-1] + dp[n-2]的这两个子问题之间不存在重复
感觉dp[n-1]也是由dp[n-2]的一部分推导出来的
我们看看未来会不会解决
//TODO



## 100

我的做法：
输出前序遍历结果存到vector，然后比较vector

题解：
递归直接比较左右子树，无需前序遍历

```c++
bool isSameTree(TreeNode* p, TreeNode* q) {
    if (!p && !q) return true; //都为空
    if (!p || !q) return false;
    return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

## 101

我的解法：
我起初的想法是做层次遍历，然后在每一层比较结果

题解：
利用树的天然特性，对称也就是两个结点的左右子树结点分别相等
记得注意一开始的判断


树的习题记得一开始要对空进行判断

## 105

主要利用分治的思想，利用在一棵树前序遍历的第一个结点是根结点的特点，找到中序遍历的根结点，然后能得到左右子树的前序和中序遍历序列，以此类推

## 121

好像不是一道DP
除了Brute Force，题解中还提供了一种One Pass的方法
用buy记录最小值，然后每次计算当前值和最小值的差值，也就是利润
这种解法的巧妙之处在于这样做不用考虑 卖 是否在 买之前发生。
因为buy是一个遍历到目前为止的最小值，res表示当前卖，因此buy肯定在res之前。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int res = 0, buy = INT_MAX;
        for (int price : prices) {
            buy = min(buy, price);
            res = max(res, price - buy);
        }
        return res;
    }
};
```

## 141

```c++ 
struct ListNode {
      int val;
      ListNode *next;
      ListNode(int x) : val(x), next(NULL) {}
};
  
class Solution {
public:
    bool hasCycle(ListNode *head) {
        vector<ListNode*> nodes = {head};
        while (head->next) {
           if (find(nodes.begin(), nodes.end(), head) == nodes.end()) {
               return true;
           }
           head = head->next;
           nodes.push_back(head);
       }
       return false;
    }
};
```

## 144

二叉树的前序遍历

#### 我的思路：

按照套路，节点如果为`null`就return跳到上一个**迭代**，相当于回溯。
每个节点被访问三次，visit(root) left(左子树返回) right(右子树返回)。
但是题目要求直接返回结果的vector，所以用这种return就会直接把结果return掉，看了好的题解，把遍历过程抽出来当dfs函数，主函数就调用这个dfs输出结果就可。注意用pass by reference。

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        dfs(root, res);
        return res;
    }

    void dfs(TreeNode* root, vector<int> &res) {
        if (root) {
            res.push_back(root->val);
            preorderTraversal(root->left);
            preorderTraversal(root->right);
        }
        return;
    }
};
```

#### 好思路

采用迭代的解法

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        Stack<TreeNode*> s;
        vector<int> res;
        TreeNode* p = root;
        while (!s.empty()||p) { //栈非空或者p不是null
            if (p) {
                s.push(p);
                res.push_back(p->val);
                p = p->left;
            }
            else {
                TreeNode* t = s.top(); //如果p的左节点为空，就把p取出来，再看它的右节点
                s.pop();
                p = t->right;
            }
        }
        
    }
```

我认为迭代和递归的解法以及DFS都比较类似，都是给定一个终止条件，然后做遍历过程。
从root节点开始，访问完就接着访问左子树，一直到左子树为空。然后访问右子树。
(从根节点开始，把所有左子节点压入栈，然后取出栈顶节点，移到右子节点中)

mooc上的解法是类似的，看起来更好理解一点

```c++
stack<TreeNode*> s;
        vector<int> res;
        TreeNode* p = root;
        while (!s.empty()||p) {
            while (p) { //一直向左把沿途节点都放进来
                res.push_back(p->val);
                s.push(p);
                p = p->left;
            }
            
            if (!s.empty()) {
                TreeNode* t = s.top(); 
                s.pop();
                p = t->right; //转向右子树
            }
            
        }
        return res;
```

## 198

- 遇到参数是一个集合，首先考虑边界条件，可能为`[]`或者`[0]`，如果后面的代码覆盖不到的话，需要单独拿出来处理。
  看到一个有点酷的写法，也就是声明dp的时候，顺便把0,1 号元素赋值。

  ```c++
  if (nums.size() <= 1) return nums.empty() ? 0 : nums[0];
  vector<int> dp = {nums[0], max(nums[0], nums[1])};
  ```

- 本质是从一个数组中，取出不相邻的数，使它们的和最大 ---- 遇到极值问题想到要用DP。

- 这样理解最好：在遍历过程中，对于每个状态i，有抢占/不抢占两种选择，因此
  `dp[i] = max(dp[i-2] + nums[i], dp[i-1]);`  前者是抢占，后者是不抢占

- 其他解法：

  ```c++
  class Solution {
  public:
    int rob(vector<int>& nums) {
        int robEven = 0, robOdd = 0, n = nums.size();
        for (int i = 0; i < n; ++i) {
            if (i % 2 == 0) {
                robEven = max(robEven + nums[i], robOdd);
            } else {
                robOdd = max(robEven, robOdd + nums[i]);
            }
        }
        return max(robEven, robOdd);
    }
  };
  ```

- ```c++
  class Solution {
  public:
      int rob(vector<int>& nums) {
          int rob = 0, notRob = 0, n = nums.size();
          for (int i = 0; i < n; ++i) {
              int preRob = rob, preNotRob = notRob;
              rob = preNotRob + nums[i];
              notRob = max(preRob, preNotRob);
          }
          return max(rob, notRob);
      }
  };
  ```



## 876

```c++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(NULL){}
};

class Solution{
public:
    ListNode* middleNode(ListNode* head) {
        vector<ListNode*> nodes = {head};
        while (nodes.back()-> next != NULL) {  //注意while条件的判断
            nodes.push_back(nodes.back()->next);
        }
        return nodes[nodes.size()/2];
    }
};
```

